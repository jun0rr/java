<?xml version="1.0" encoding="ISO-8859-1" standalone="yes"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>urn:infinispan:config:8.2</title>
<style>
               body { font-family: 'sans-serif'; }
               div.element, div.complexType { margin: 0 0 1em 1em; border-left: 5px solid #4477aa; border-bottom: 2px groove #4477aa;}
               table { border: 1px solid red; border-collapse: collapse; margin: 5px; width: 95%; }
               th { text-align: left; background: #eeeeee; color: #773333; }
               td, th { border: 1px solid gray; }
               h3 { border: 1px solid #4477aa; background: #eeeeee; color: #4477aa; margin: 0.3em 0 0 0; padding: 0.3em; }
               a { text-decoration: none; color: #4477aa; }
               a:hover { color: white; background: #4477aa; }
               .error { color: white; background: red; }
               .content { }
               .heading { cursor: pointer; }
               .complexType, .simpleType {  }
               table.enumeration { border: 0; margin: 0; }
               #global {
                  position: fixed;
                  top: 1em;
                  right: 1em;
                  border: 1px solid #4477aa;
                  border-bottom: 2px groove #4477aa;
                  z-index: 100;
                  background: white;
                  padding: 0.5em;
               }
            </style>
<script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js">//</script>
<script type="text/javascript">
               jQuery(document).ready(function() {
                 jQuery(".heading").click(function() {
                   jQuery(this).next(".content").slideToggle(500);
                 });
                 jQuery("#global a").click(function() {
                   jQuery(".content").toggle();
                 });
               });
            </script>
</head>
<body>
<h1>urn:infinispan:config:8.2</h1>
<div class="element">
<h3 class="heading">infinispan</h3>
<div class="content">
<p>
        Defines the configuration for Infinispan, for the cache manager configuration, for the default cache, and for named caches.
      </p>
<div class="element">
<h3 class="heading">jgroups?</h3>
<div class="content">
<p>Defines JGroups stacks.</p>
        Defines JGroups transport stacks.
      <table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>transport</td>
<td>string</td>
<td>org.infinispan.remoting.transport.jgroups.JGroupsTransport</td>
<td>Class that represents a network transport. Must implement org.infinispan.remoting.transport.Transport.</td>
</tr>
</table>
<div class="element">
<h3 class="heading">stack-file+</h3>
<div class="content">
<p/>
              Defines an individual JGroups stack, pointing to the file containing its definition.
            <table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>name</td>
<td>string</td>
<td/>
<td>Name of the stack, to be referenced by transport's stack attribute.</td>
</tr>
<tr>
<td>path</td>
<td>string</td>
<td/>
<td>Path of JGroups configuration file containing stack definition.</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="element">
<h3 class="heading">threads?</h3>
<div class="content">
<p>Defines the threading subsystem.</p>
        The threading subsystem, used to declare manageable thread pools and resources.
      <div class="element">
<h3 class="heading">thread-factory*</h3>
<div class="content">
<p/>
              
                A thread factory (implementing java.util.concurrent.ThreadFactory).  The "name" attribute is
                the bean name of the created thread factory.  The optional "priority" attribute may be used to specify
                the thread priority of created threads.  The optional "group-name" attribute specifies the name of a the
                thread group to create for this thread factory.

                The "thread-name-pattern" is the template used to create names for threads.  The following patterns
                may be used:

                 %% - emit a percent sign
                 %t - emit the per-factory thread sequence number
                 %g - emit the global thread sequence number
                 %f - emit the factory sequence number
                 %i - emit the thread ID
                 %G - emit the thread group name
                    
            <table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>name</td>
<td>string</td>
<td/>
<td/>
</tr>
<tr>
<td>group-name</td>
<td>string</td>
<td/>
<td/>
</tr>
<tr>
<td>thread-name-pattern</td>
<td>string</td>
<td/>
<td/>
</tr>
<tr>
<td>priority</td>
<td>string</td>
<td/>
<td/>
</tr>
</table>
</div>
</div>
<div class="element">
<h3 class="heading">blocking-bounded-queue-thread-pool*</h3>
<div class="content">
<p/>
              
                A thread pool executor with a bounded queue.  Such a thread pool has a core size and a queue with an
                upper bound.  When a task is submitted, if the number of running threads is less than the core size,
                a new thread is created.  Otherwise, the task is placed in queue.  If too many tasks are allowed to be
                submitted to this type of executor, an out of memory condition may occur.

                The "name" attribute is the bean name of the created executor.

                The "max-threads" attribute must be used to specify the maximum thread pool size.
                The "core-threads" attribute defines the number of threads to keep in the pool.

                The nested "keepalive-time" element may used to specify the amount of time that pool threads should
                be kept running when idle; if not specified, threads will run until the executor is shut down.
                The "thread-factory" element specifies the bean name of a specific thread factory to use to create worker
                threads.
                    
            <table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>name</td>
<td>string</td>
<td/>
<td/>
</tr>
<tr>
<td>thread-factory</td>
<td>string</td>
<td/>
<td/>
</tr>
<tr>
<td>max-threads</td>
<td>int</td>
<td/>
<td/>
</tr>
<tr>
<td>core-threads</td>
<td>int</td>
<td/>
<td/>
</tr>
<tr>
<td>keepalive-time</td>
<td>string</td>
<td/>
<td/>
</tr>
<tr>
<td>queue-length</td>
<td>string</td>
<td/>
<td/>
</tr>
</table>
</div>
</div>
<div class="element">
<h3 class="heading">cached-thread-pool*</h3>
<div class="content">
<p/>
              
                A thread pool executor that creates new threads as needed, but
                will reuse previously constructed threads when they are available.

                The "name" attribute is the bean name of the created executor.
                The "thread-factory" element specifies the bean name of a specific thread factory to use to create worker
                threads.
                    
            <table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>name</td>
<td>string</td>
<td/>
<td/>
</tr>
<tr>
<td>thread-factory</td>
<td>string</td>
<td/>
<td/>
</tr>
</table>
</div>
</div>
<div class="element">
<h3 class="heading">scheduled-thread-pool*</h3>
<div class="content">
<p/>
              
                A thread pool executor that creates a single-threaded executor
                that can schedule commands to run after a given delay, or to
                execute periodically.

                The "name" attribute is the bean name of the created executor.
                The "thread-factory" element specifies the bean name of a specific thread factory to use to create worker
                threads.
                    
            <table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>name</td>
<td>string</td>
<td/>
<td/>
</tr>
<tr>
<td>thread-factory</td>
<td>string</td>
<td/>
<td/>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="element">
<h3 class="heading">cache-container</h3>
<div class="content">
<p>Defines an embedded cache container.</p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>name</td>
<td>string</td>
<td/>
<td>Uniquely identifies this cache container.</td>
</tr>
<tr>
<td>aliases</td>
<td/>
<td/>
<td>Unused XML attribute</td>
</tr>
<tr>
<td>jndi-name</td>
<td>string</td>
<td/>
<td>Unused XML attribute</td>
</tr>
<tr>
<td>default-cache</td>
<td>string</td>
<td/>
<td>Indicates the default cache for this cache container.</td>
</tr>
<tr>
<td>start</td>
<td>
<span class="error">FIXME</span>
</td>
<td/>
<td>Unused XML attribute</td>
</tr>
<tr>
<td>async-executor</td>
<td>string</td>
<td/>
<td>Defines the executor used for asynchronous cache operations.
        </td>
</tr>
<tr>
<td>listener-executor</td>
<td>string</td>
<td/>
<td>Defines the executor used for asynchronous cache listener notifications.
        </td>
</tr>
<tr>
<td>eviction-executor</td>
<td>string</td>
<td/>
<td>DEPRECATED Defines the scheduled executor used for evictions.  The expiration-executor type should be used instead.</td>
</tr>
<tr>
<td>expiration-executor</td>
<td>string</td>
<td/>
<td>Defines the scheduled executor used for expirations.</td>
</tr>
<tr>
<td>replication-queue-executor</td>
<td>string</td>
<td/>
<td>Deprecated. Defines the scheduled executor used by the asynchronous replication queue.</td>
</tr>
<tr>
<td>persistence-executor</td>
<td>string</td>
<td/>
<td>Configuration for the executor service used when interacting with the persistent store.</td>
</tr>
<tr>
<td>state-transfer-executor</td>
<td>string</td>
<td/>
<td>Configuration for the executor service used when applying state from other nodes during the state transfer.</td>
</tr>
<tr>
<td>module</td>
<td>string</td>
<td>org.jboss.as.clustering.infinispan</td>
<td>Unused XML attribute</td>
</tr>
<tr>
<td>statistics</td>
<td>boolean</td>
<td>true</td>
<td>Determines whether or not the cache container should collect statistics.  Keep disabled for optimal performance.</td>
</tr>
<tr>
<td>shutdown-hook</td>
<td>
<table class="enumeration">
<tr>
<td title="Use the default shutdown hook behaviour (REGISTER)">DEFAULT</td>
<td>Use the default shutdown hook behaviour (REGISTER)</td>
</tr>
<tr>
<td title="Register a shutdown hook">REGISTER</td>
<td>Register a shutdown hook</td>
</tr>
<tr>
<td title="Don't register a shutdown hook">DONT_REGISTER</td>
<td>Don't register a shutdown hook</td>
</tr>
</table>
</td>
<td/>
<td>
          Behavior of the JVM shutdown hook registered by the cache
        </td>
</tr>
</table>
<div class="element">
<h3 class="heading">transport?</h3>
<div class="content">
<p>Overrides the transport characteristics for this cache container.</p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>stack</td>
<td>string</td>
<td/>
<td>Defines the jgroups stack used by the transport.</td>
</tr>
<tr>
<td>cluster</td>
<td>string</td>
<td/>
<td>Defines the name for the underlying group communication cluster.</td>
</tr>
<tr>
<td>executor</td>
<td>string</td>
<td/>
<td>Defines the executor used for asynchronous transport communication.</td>
</tr>
<tr>
<td>total-order-executor</td>
<td>string</td>
<td/>
<td>Configuration for the total order executor service used to concurrent validate non conflicting transactions.</td>
</tr>
<tr>
<td>remote-command-executor</td>
<td>string</td>
<td/>
<td>Configuration for the executor service used to execute remote commands. Use org.infinispan.executors.WithinThreadExecutorFactory to disable.</td>
</tr>
<tr>
<td>lock-timeout</td>
<td>long</td>
<td>240000</td>
<td>
          Infinispan uses a distributed lock to maintain a coherent transaction log during state transfer or rehashing, which means that only one cache can be doing state transfer or rehashing at the same time.
          This constraint is in place because more than one cache could be involved in a transaction.
          This timeout controls the time to wait to acquire a distributed lock.
        </td>
</tr>
<tr>
<td>node-name</td>
<td>string</td>
<td/>
<td>
          Name of the current node. This is a friendly name to make logs, etc. make more sense. Defaults to a combination of host name and a random number (to differentiate multiple nodes on the same host)
        </td>
</tr>
<tr>
<td>machine</td>
<td>string</td>
<td/>
<td>
          The id of the machine where this node runs.
        </td>
</tr>
<tr>
<td>rack</td>
<td>string</td>
<td/>
<td>
          The id of the rack where this node runs.
        </td>
</tr>
<tr>
<td>site</td>
<td>string</td>
<td/>
<td>
          The id of the site where this node runs.
        </td>
</tr>
<tr>
<td>initial-cluster-size</td>
<td>int</td>
<td/>
<td>
          The minimum number of nodes that must join the cluster for the cache manager to start
        </td>
</tr>
<tr>
<td>initial-cluster-timeout</td>
<td>long</td>
<td/>
<td>
          The amount of time in milliseconds to wait for a cluster with sufficient nodes to form. Defaults to 60000
        </td>
</tr>
</table>
</div>
</div>
<div class="element">
<h3 class="heading">security?</h3>
<div class="content">
<p>Configures security for this cache container.</p>
<div class="element">
<h3 class="heading">authorization?</h3>
<div class="content">
<p>
            Configures the global authorization role to permission mapping. The presence of this element in the configuration implicitly enables authorization.
          </p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>audit-logger</td>
<td>string</td>
<td/>
<td>
                Class of the audit logger.
              </td>
</tr>
</table>
              <div class="element">
<h3 class="heading">identity-role-mapper</h3>
<div class="content">
<p>
                    Uses the identity role mapper where principal names are converted as-is into role names.
                  </p>
</div>
</div>
              <div class="element">
<h3 class="heading">common-name-role-mapper</h3>
<div class="content">
<p>
                    Uses the common name role mapper which assumes principal names are in Distinguished Name format and extracts the Common Name to use as a role
                  </p>
</div>
</div>
              <div class="element">
<h3 class="heading">cluster-role-mapper</h3>
<div class="content">
<p>
                    Uses the cluster role mapper which stores the principal to role mappings within the cluster registry.
                  </p>
</div>
</div>
              <div class="element">
<h3 class="heading">custom-role-mapper</h3>
<div class="content">
<p>
                    Uses a custom role mapper.
                  </p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>class</td>
<td>string</td>
<td/>
<td>
                        Class of the custom principal to role mapper
                      </td>
</tr>
</table>
</div>
</div>
            <div class="element">
<h3 class="heading">role*</h3>
<div class="content">
<p>
                  Defines a new role name and assigns permissions to it.
                </p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>name</td>
<td>string</td>
<td/>
<td>
                      Defines the name of the role.
                    </td>
</tr>
<tr>
<td>permissions</td>
<td>
<table class="enumeration">
<tr>
<td title="&#10;            Allows control of a cache's lifecycle (i.e. starting and stopping a cache)&#10;          ">LIFECYCLE</td>
<td>
            Allows control of a cache's lifecycle (i.e. starting and stopping a cache)
          </td>
</tr>
<tr>
<td title="&#10;            Allows reading data from a cache&#10;          ">READ</td>
<td>
            Allows reading data from a cache
          </td>
</tr>
<tr>
<td title="&#10;            Allows writing data to a cache&#10;          ">WRITE</td>
<td>
            Allows writing data to a cache
          </td>
</tr>
<tr>
<td title="&#10;            Allows performing task execution (e.g. distributed executors, map/reduce) on a cache&#10;          ">EXEC</td>
<td>
            Allows performing task execution (e.g. distributed executors, map/reduce) on a cache
          </td>
</tr>
<tr>
<td title="&#10;            Allows attaching listeners to a cache&#10;          ">LISTEN</td>
<td>
            Allows attaching listeners to a cache
          </td>
</tr>
<tr>
<td title="&#10;            Allows bulk-read operations (e.g. obtaining all the keys in a cache)&#10;          ">BULK_READ</td>
<td>
            Allows bulk-read operations (e.g. obtaining all the keys in a cache)
          </td>
</tr>
<tr>
<td title="&#10;            Allows bulk-write operations (e.g. clearing a cache)&#10;          ">BULK_WRITE</td>
<td>
            Allows bulk-write operations (e.g. clearing a cache)
          </td>
</tr>
<tr>
<td title="&#10;            Allows performing &quot;administrative&quot; operations on a cache&#10;          ">ADMIN</td>
<td>
            Allows performing "administrative" operations on a cache
          </td>
</tr>
<tr>
<td title="&#10;            Aggregate permission which implies all of the others&#10;          ">ALL</td>
<td>
            Aggregate permission which implies all of the others
          </td>
</tr>
<tr>
<td title="&#10;            Aggregate permission which implies all read permissions (READ and BULK_READ)&#10;          ">ALL_READ</td>
<td>
            Aggregate permission which implies all read permissions (READ and BULK_READ)
          </td>
</tr>
<tr>
<td title="&#10;            Aggregate permission which implies all write permissions (WRITE and BULK_WRITE)&#10;          ">ALL_WRITE</td>
<td>
            Aggregate permission which implies all write permissions (WRITE and BULK_WRITE)
          </td>
</tr>
<tr>
<td title="&#10;            Permission which means no permissions&#10;          ">NONE</td>
<td>
            Permission which means no permissions
          </td>
</tr>
</table>
</td>
<td/>
<td>
                      Defines the list of permissions for the role.
                    </td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="element">
<h3 class="heading">serialization?</h3>
<div class="content">
<p>Specifies how data serialization will be performed by the cache container.</p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>marshaller</td>
<td>string</td>
<td>org.infinispan.marshall.core.VersionAwareMarshaller</td>
<td>
          Fully qualified name of the marshaller to use. It must implement org.infinispan.marshall.StreamingMarshaller
        </td>
</tr>
<tr>
<td>version</td>
<td>string</td>
<td>71</td>
<td>
          Largest allowable version to use when marshalling internal state. Set this to the lowest version cache instance in your cluster to ensure compatibility of communications. However, setting this too low will mean you lose out on the benefit of improvements in newer versions of the marshaller.
        </td>
</tr>
</table>
<div class="element">
<h3 class="heading">advanced-externalizer*</h3>
<div class="content">
<p>
            AdvancedExternalizer provides an alternative way to provide externalizers for marshalling/unmarshalling user defined classes that overcome the deficiencies of the more user-friendly externalizer definition  model explained in Externalizer.
          </p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>class</td>
<td>string</td>
<td/>
<td>
                Class of the custom externalizer
              </td>
</tr>
<tr>
<td>id</td>
<td>int</td>
<td/>
<td>
                Id of the custom externalizer
              </td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="element">
<h3 class="heading">jmx?</h3>
<div class="content">
<p>Defines JMX management details.</p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>domain</td>
<td>string</td>
<td>org.infinispan</td>
<td>
          If JMX statistics are enabled then all 'published' JMX objects will appear under this name. This is optional, if not specified an object name will be created for you by default.
        </td>
</tr>
<tr>
<td>mbean-server-lookup</td>
<td>string</td>
<td>org.infinispan.jmx.PlatformMBeanServerLookup</td>
<td>
          Class that will attempt to locate a JMX MBean server to bind to. Defaults to using the platform MBean server.
        </td>
</tr>
<tr>
<td>duplicate-domains</td>
<td>boolean</td>
<td>false</td>
<td>
          If true, multiple cache manager instances could be configured under the same configured JMX domain. Each cache manager will in practice use a different JMX domain that has been calculated based on the configured one by adding an incrementing index to it.
        </td>
</tr>
</table>
<div class="element">
<h3 class="heading">property*</h3>
<div class="content">
<p>A jmx property with name and value to be passed to the MBean Server lookup instance.</p>
</div>
</div>
</div>
</div>
<div class="element">
<h3 class="heading">global-state?</h3>
<div class="content">
<p>Defines the global state persistence configuration. If this element is not present, global state persistence will be disabled.</p>
<div class="element">
<h3 class="heading">persistent-location</h3>
<div class="content">
<p>
            Defines the filesystem path where persistent state data which needs to survive container restarts
            should be stored. The data stored at this location is required for graceful
            shutdown and restore. Defaults to the user.dir system property which usually is where the
            application was started. This value should be overridden to a more appropriate location.
          </p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>relative-to</td>
<td>string</td>
<td>jboss.server.data.dir</td>
<td>Ignored in embedded mode.</td>
</tr>
<tr>
<td>path</td>
<td>string</td>
<td/>
<td>
          Defines the path where global state for this cache-container will be stored.
        </td>
</tr>
</table>
</div>
</div>
<div class="element">
<h3 class="heading">temporary-location?</h3>
<div class="content">
<p>
            Defines the filesystem path where temporary state should be stored. Defaults to the value of the
            java.io.tmpdir system property.
          </p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>relative-to</td>
<td>string</td>
<td>jboss.server.data.dir</td>
<td>Ignored in embedded mode.</td>
</tr>
<tr>
<td>path</td>
<td>string</td>
<td/>
<td>
          Defines the path where global state for this cache-container will be stored.
        </td>
</tr>
</table>
</div>
</div>
</div>
</div>
        <div class="element">
<h3 class="heading">local-cache</h3>
<div class="content">
<p>Defines a LOCAL mode cache.</p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>simple-cache</td>
<td>
<span class="error">FIXME</span>
</td>
<td>false</td>
<td>
              This cache will be using optimized (faster) implementation that does not support transactions/invocation batching, persistence, custom interceptors, indexing, store-as-binary or compatibility. Also, this type of cache does not support Map-Reduce jobs or Distributed Executor framework.
            </td>
</tr>
</table>
<div>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>name</td>
<td>ID</td>
<td/>
<td>Uniquely identifies this cache within its cache container.</td>
</tr>
<tr>
<td>configuration</td>
<td>IDREF</td>
<td/>
<td>The name of the cache configuration which this configuration inherits from.</td>
</tr>
<tr>
<td>start</td>
<td>
<span class="error">FIXME</span>
</td>
<td/>
<td>Unused XML attribute</td>
</tr>
<tr>
<td>jndi-name</td>
<td>string</td>
<td/>
<td>Unused XML attribute</td>
</tr>
<tr>
<td>module</td>
<td>string</td>
<td/>
<td>Unused XML attribute</td>
</tr>
<tr>
<td>statistics</td>
<td>boolean</td>
<td>true</td>
<td>Determines whether or not the cache should collect statistics.  Keep disabled for optimal performance.</td>
</tr>
<tr>
<td>statistics-available</td>
<td>boolean</td>
<td>true</td>
<td>If set to false, statistics gathering cannot be enabled during runtime. Keep disabled for optimal performance.</td>
</tr>
<tr>
<td>deadlock-detection-spin</td>
<td>long</td>
<td>100</td>
<td>
          Time period that determines how often is lock acquisition attempted within maximum time allowed to acquire a particular lock. Defaults to 100ms.
        </td>
</tr>
<tr>
<td>unreliable-return-values</td>
<td>boolean</td>
<td>false</td>
<td>
          Specifies whether Infinispan is allowed to disregard the Map contract when providing return values for org.infinispan.Cache#put(Object, Object) and org.infinispan.Cache#remove(Object) methods.
        </td>
</tr>
</table>
<div class="element">
<h3 class="heading">backups?</h3>
<div class="content">
<p>The state transfer configuration for distribution and replicated caches.</p>
<div class="element">
<h3 class="heading">backup*</h3>
<div class="content">
<p>Configures a specific site where this cache backups data.</p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>site</td>
<td>string</td>
<td/>
<td>Name of the remote site where this cache backups data.</td>
</tr>
<tr>
<td>strategy</td>
<td>
<table class="enumeration">
<tr>
<td title="Enables asynchronous mode.">ASYNC</td>
<td>Enables asynchronous mode.</td>
</tr>
<tr>
<td title="Enables synchronous mode.">SYNC</td>
<td>Enables synchronous mode.</td>
</tr>
</table>
</td>
<td>ASYNC</td>
<td>The strategy used for backing up data: "SYNC" or "ASYNC". Defaults to "ASYNC"</td>
</tr>
<tr>
<td>failure-policy</td>
<td>
<table class="enumeration">
<tr>
<td title="Ignore backup failures.">IGNORE</td>
<td>Ignore backup failures.</td>
</tr>
<tr>
<td title="Warn of backup failures.">WARN</td>
<td>Warn of backup failures.</td>
</tr>
<tr>
<td title="Fail local operations when a backup failure occurs.">FAIL</td>
<td>Fail local operations when a backup failure occurs.</td>
</tr>
<tr>
<td title="Invoke a user-specified failure policy (set via the failure-policy-class attribute)">CUSTOM</td>
<td>Invoke a user-specified failure policy (set via the failure-policy-class attribute)</td>
</tr>
</table>
</td>
<td>WARN</td>
<td>Decides what the system would do in case of failure during backup. Defaults to "WARN"</td>
</tr>
<tr>
<td>timeout</td>
<td>long</td>
<td>10000</td>
<td>The timeout(millis) to be used when backing up data remotely. Defaults to 10 secs.</td>
</tr>
<tr>
<td>enabled</td>
<td>boolean</td>
<td>true</td>
<td>If 'false' then no data is backed up to this site. Defaults to 'true'.</td>
</tr>
<tr>
<td>two-phase-commit</td>
<td>boolean</td>
<td>false</td>
<td>
          Configures whether the replication happens in a 1PC or 2PC when using SYNC backup strategy. Defaults to "false".
          CacheConfigurationException is thrown when used with ASYNC backup strategy.
        </td>
</tr>
<tr>
<td>failure-policy-class</td>
<td>string</td>
<td/>
<td>
          If the 'backupFailurePolicy' is set to 'CUSTOM' then this attribute is
          required and should
          contain the fully qualified name of a class implementing
          org.infinispan.xsite.CustomFailurePolicy.
        </td>
</tr>
</table>
<div class="element">
<h3 class="heading">take-offline?</h3>
<div class="content">
<p>Determines whether this backup is taken offline (ignored) after a certain number of tries.</p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>after-failures</td>
<td>int</td>
<td>0</td>
<td>The number of failed request operations after which this site should be taken offline. Defaults to 0 (never). A negative value would mean that the site will be taken offline after 'min-wait'.</td>
</tr>
<tr>
<td>min-wait</td>
<td>long</td>
<td>0</td>
<td>The minimal number of millis to wait before taking this site offline, even in the case 'after-failures' is reached. If smaller or equal to 0, then only 'after-failures' is considered.</td>
</tr>
</table>
</div>
</div>
<div class="element">
<h3 class="heading">state-transfer?</h3>
<div class="content">
<p>
            Configures the properties needed to transfer the state for this site.
          </p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>chunk-size</td>
<td>int</td>
<td>512</td>
<td>
                If &gt; 0, the state will be transferred in batches of {@code chunkSize} cache entries.
                If &lt;= 0, the state will be transferred in all at once. Not recommended. Defaults to 512.
              </td>
</tr>
<tr>
<td>timeout</td>
<td>long</td>
<td>1200000</td>
<td>
                The time (in milliseconds) to wait for the backup site acknowledge the state chunk
                received and applied. Default value is 20 min.
              </td>
</tr>
<tr>
<td>max-retries</td>
<td>int</td>
<td>30</td>
<td>
                The maximum number of retries when a push state command fails. A value &lt;= 0 (zero) mean that
                the command will not retry. Default value is 30.
              </td>
</tr>
<tr>
<td>wait-time</td>
<td>long</td>
<td>2000</td>
<td>
                The waiting time (in milliseconds) between each retry. The value should be &gt; 0 (zero). Default
                value is 2 seconds.
              </td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="element">
<h3 class="heading">backup-for?</h3>
<div class="content">
<p>
            Configures this cache as a backup for a remote cache.
          </p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>remote-cache</td>
<td>string</td>
<td/>
<td>
                The name of the remote cache that backups data here.
              </td>
</tr>
<tr>
<td>remote-site</td>
<td>string</td>
<td/>
<td>
                The name of the remote site containing the cache that backups data here.
              </td>
</tr>
</table>
</div>
</div>
<div class="element">
<h3 class="heading">locking?</h3>
<div class="content">
<p>The locking configuration of the cache.</p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>isolation</td>
<td>
<table class="enumeration">
<tr>
<td title="No locking isolation will be performed. This is only valid in local mode. In clustered mode, READ_COMMITTED will be used instead.">NONE</td>
<td>No locking isolation will be performed. This is only valid in local mode. In clustered mode, READ_COMMITTED will be used instead.</td>
</tr>
<tr>
<td title="Unsupported. Actually configures READ_COMMITTED">READ_UNCOMMITTED</td>
<td>Unsupported. Actually configures READ_COMMITTED</td>
</tr>
<tr>
<td title="Read committed is an isolation level that guarantees that any data read is committed at the moment it is read. However, depending on the outcome of other transactions, successive reads may return different results">READ_COMMITTED</td>
<td>Read committed is an isolation level that guarantees that any data read is committed at the moment it is read. However, depending on the outcome of other transactions, successive reads may return different results</td>
</tr>
<tr>
<td title="Repeatable read is an isolation level that guarantees that any data read is committed at the moment it is read and that, within a transaction, successive reads will always return the same data.">REPEATABLE_READ</td>
<td>Repeatable read is an isolation level that guarantees that any data read is committed at the moment it is read and that, within a transaction, successive reads will always return the same data.</td>
</tr>
<tr>
<td title="Unsupported. Actually configures REPEATABLE_READ">SERIALIZABLE</td>
<td>Unsupported. Actually configures REPEATABLE_READ</td>
</tr>
</table>
</td>
<td>READ_COMMITTED</td>
<td>Sets the cache locking isolation level. Infinispan only supports READ_COMMITTED or REPEATABLE_READ isolation level.</td>
</tr>
<tr>
<td>striping</td>
<td>boolean</td>
<td>false</td>
<td>If true, a pool of shared locks is maintained for all entries that need to be locked. Otherwise, a lock is created per entry in the cache. Lock striping helps control memory footprint but may reduce concurrency in the system.</td>
</tr>
<tr>
<td>acquire-timeout</td>
<td>long</td>
<td>10000</td>
<td>Maximum time to attempt a particular lock acquisition.</td>
</tr>
<tr>
<td>concurrency-level</td>
<td>int</td>
<td>32</td>
<td>Concurrency level for lock containers. Adjust this value according to the number of concurrent threads interacting with Infinispan.</td>
</tr>
<tr>
<td>write-skew</td>
<td>boolean</td>
<td>false</td>
<td>
          This setting is only applicable in the case of REPEATABLE_READ. When write skew check is set to false, if the writer at commit time discovers that the working entry and the underlying entry have different versions, the working entry will overwrite the underlying entry. If true, such version conflict - known as a write-skew - will throw an Exception. Defaults to false.
        </td>
</tr>
</table>
</div>
</div>
<div class="element">
<h3 class="heading">transaction?</h3>
<div class="content">
<p>The cache transaction configuration.</p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>mode</td>
<td>
<table class="enumeration">
<tr>
<td title="Cache will not enlist within transactions.">NONE</td>
<td>Cache will not enlist within transactions.</td>
</tr>
<tr>
<td title="Uses batching to group cache operations together.">BATCH</td>
<td>Uses batching to group cache operations together.</td>
</tr>
<tr>
<td title="Cache will enlist within transactions as a javax.transaction.Synchronization">NON_XA</td>
<td>Cache will enlist within transactions as a javax.transaction.Synchronization</td>
</tr>
<tr>
<td title="Cache will enlist within transactions as a javax.transaction.xa.XAResource, without recovery.">NON_DURABLE_XA</td>
<td>Cache will enlist within transactions as a javax.transaction.xa.XAResource, without recovery.</td>
</tr>
<tr>
<td title="Cache will enlist within transactions as a javax.transaction.xa.XAResource, with recovery.">FULL_XA</td>
<td>Cache will enlist within transactions as a javax.transaction.xa.XAResource, with recovery.</td>
</tr>
</table>
</td>
<td>NONE</td>
<td>Sets the cache transaction mode to one of NONE, BATCH, NON_XA, NON_DURABLE_XA, FULL_XA.</td>
</tr>
<tr>
<td>stop-timeout</td>
<td>long</td>
<td>30000</td>
<td>If there are any ongoing transactions when a cache is stopped, Infinispan waits for ongoing remote and local transactions to finish. The amount of time to wait for is defined by the cache stop timeout.</td>
</tr>
<tr>
<td>locking</td>
<td>
<table class="enumeration">
<tr>
<td title="Enables Optimistic locking.">OPTIMISTIC</td>
<td>Enables Optimistic locking.</td>
</tr>
<tr>
<td title="Enables Pessimistic locking.">PESSIMISTIC</td>
<td>Enables Pessimistic locking.</td>
</tr>
</table>
</td>
<td>OPTIMISTIC</td>
<td>The locking mode for this cache, one of OPTIMISTIC or PESSIMISTIC.</td>
</tr>
<tr>
<td>transaction-manager-lookup</td>
<td>string</td>
<td>org.infinispan.transaction.lookup.GenericTransactionManagerLookup.GenericTransactionManagerLookup</td>
<td>
          Configure Transaction manager lookup directly using an instance of TransactionManagerLookup. Calling this method marks the cache as transactional.
        </td>
</tr>
<tr>
<td>complete-timeout</td>
<td>long</td>
<td>60000</td>
<td>
          The duration (millis) in which to keep information about the completion of a transaction. Defaults to 60000.
        </td>
</tr>
<tr>
<td>reaper-interval</td>
<td>long</td>
<td>30000</td>
<td>
          The time interval (millis) at which the thread that cleans up transaction completion information kicks in. Defaults to 30000.
        </td>
</tr>
<tr>
<td>auto-commit</td>
<td>boolean</td>
<td>true</td>
<td>
          If the cache is transactional and transactionAutoCommit is enabled then for single operation transactions the user doesn't need to manually start a transaction, but a transactions is injected by the system. Defaults to true.
        </td>
</tr>
<tr>
<td>protocol</td>
<td>
<table class="enumeration">
<tr>
<td title="">DEFAULT</td>
<td/>
</tr>
<tr>
<td title="">TOTAL_ORDER</td>
<td/>
</tr>
</table>
</td>
<td/>
<td>
          Configures the commit protocol to use.
        </td>
</tr>
<tr>
<td>recovery-cache</td>
<td>string</td>
<td>__recoveryInfoCacheName__</td>
<td>
          Sets the name of the cache where recovery related information is held. The cache's default name is "__recoveryInfoCacheName__"
        </td>
</tr>
<tr>
<td>notifications</td>
<td>boolean</td>
<td>true</td>
<td>
          Enables or disables triggering transactional notifications on cache listeners. By default is enabled.
        </td>
</tr>
</table>
</div>
</div>
<div class="element">
<h3 class="heading">eviction?</h3>
<div class="content">
<p>The cache eviction configuration.</p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>strategy</td>
<td>
<table class="enumeration">
<tr>
<td title="Never evict entries. This is the default.">NONE</td>
<td>Never evict entries. This is the default.</td>
</tr>
<tr>
<td title="Actually activates LRU.">UNORDERED</td>
<td>Actually activates LRU.</td>
</tr>
<tr>
<td title="Deprecated. Actually activates LRU.">FIFO</td>
<td>Deprecated. Actually activates LRU.</td>
</tr>
<tr>
<td title="Least-Recently Used policy.">LRU</td>
<td>Least-Recently Used policy.</td>
</tr>
<tr>
<td title="Low Inter-reference Recency Set. An improved version of LRU which uses cache-locality access information to better decide which data to evict.">LIRS</td>
<td>Low Inter-reference Recency Set. An improved version of LRU which uses cache-locality access information to better decide which data to evict.</td>
</tr>
<tr>
<td title="Eviction will be performed manually. Equivalent internally to NONE.">MANUAL</td>
<td>Eviction will be performed manually. Equivalent internally to NONE.</td>
</tr>
</table>
</td>
<td>NONE</td>
<td>Sets the cache eviction strategy. Available options are 'UNORDERED', 'FIFO', 'LRU', 'LIRS' and 'NONE' (to disable eviction).</td>
</tr>
<tr>
<td>max-entries</td>
<td>long</td>
<td>-1</td>
<td>Deprecated since 8.1. Use the size attribute instead.</td>
</tr>
<tr>
<td>thread-policy</td>
<td>
<table class="enumeration">
<tr>
<td title="Fires the eviction events from the same thread which is performing the eviction ">PIGGYBACK</td>
<td>Fires the eviction events from the same thread which is performing the eviction </td>
</tr>
<tr>
<td title="Use the default eviction listener thread policy (PIGGYBACK)">DEFAULT</td>
<td>Use the default eviction listener thread policy (PIGGYBACK)</td>
</tr>
</table>
</td>
<td>DEFAULT</td>
<td>
          Threading policy for eviction. Defaults to using the DEFAULT eviction policy.
        </td>
</tr>
<tr>
<td>type</td>
<td>
<table class="enumeration">
<tr>
<td title="Evicts entries from the cache when a specified count has been set">COUNT</td>
<td>Evicts entries from the cache when a specified count has been set</td>
</tr>
<tr>
<td title="Evicts entries from the cache when a specified memory usage has been reached. Memory usage is computed using an approximation which is tailored for the HotSpot VM. This can only be used when both key and values are stored as byte arrays. To guarantee only byte arrays are stored it is recommended to run with store as binary for both keys and values">MEMORY</td>
<td>Evicts entries from the cache when a specified memory usage has been reached. Memory usage is computed using an approximation which is tailored for the HotSpot VM. This can only be used when both key and values are stored as byte arrays. To guarantee only byte arrays are stored it is recommended to run with store as binary for both keys and values</td>
</tr>
</table>
</td>
<td>COUNT</td>
<td>Specifies whether to use entry count or memory-based approximation to decide when to evict entries.</td>
</tr>
<tr>
<td>size</td>
<td>long</td>
<td>-1</td>
<td>Maximum size to use for eviction. When using the COUNT type, this is the maximum number of entries in a cache instance. When using the MEMORY threshold policy, this is the maximum number of allocated bytes used by a cache's datacontainer. A value of -1 means no limit. This is currently limited to 2^48 - 1 in size.</td>
</tr>
</table>
</div>
</div>
<div class="element">
<h3 class="heading">expiration?</h3>
<div class="content">
<p>The cache expiration configuration.</p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>max-idle</td>
<td>long</td>
<td>-1</td>
<td>Maximum idle time a cache entry will be maintained in the cache, in milliseconds. If the idle time is exceeded, the entry will be expired cluster-wide. -1 means the entries never expire.</td>
</tr>
<tr>
<td>lifespan</td>
<td>long</td>
<td>-1</td>
<td>Maximum lifespan of a cache entry, after which the entry is expired cluster-wide, in milliseconds. -1 means the entries never expire.</td>
</tr>
<tr>
<td>interval</td>
<td>long</td>
<td>60000</td>
<td>Interval (in milliseconds) between subsequent runs to purge expired entries from memory and any cache stores. If you wish to disable the periodic eviction process altogether, set interval to -1.</td>
</tr>
</table>
</div>
</div>
<div class="element">
<h3 class="heading">compatibility?</h3>
<div class="content">
<p>The cache compatibility mode configuration.</p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>marshaller</td>
<td>string</td>
<td/>
<td>A marshaller to use for compatibility conversions.</td>
</tr>
</table>
</div>
</div>
<div class="element">
<h3 class="heading">store-as-binary?</h3>
<div class="content">
<p>Configures the cache to store data in binary format.</p>
        Controls whether when stored in memory, keys and values are stored as references to their original objects, or in a serialized, binary format.  There are benefits to both approaches, but often if used in a clustered mode, storing objects as binary means that the cost of serialization happens early on, and can be amortized.  Further, deserialization costs are incurred lazily which improves throughput. It is possible to control this on a fine-grained basis: you can choose to just store keys or values as binary, or both.
      <table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>keys</td>
<td>boolean</td>
<td>true</td>
<td>
          Specify whether keys are stored as binary or not. Enabled by default if the "enabled" attribute is set to true.
        </td>
</tr>
<tr>
<td>values</td>
<td>boolean</td>
<td>true</td>
<td>
          Specify whether values are stored as binary or not. Enabled by default if the "enabled" attribute is set to true.
        </td>
</tr>
</table>
</div>
</div>
<div class="element">
<h3 class="heading">persistence?</h3>
<div class="content">
<p>Configures the cache's persistence layer.</p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>passivation</td>
<td>boolean</td>
<td>false</td>
<td>
          If true, data is only written to the cache store when it is evicted from memory, a phenomenon known as 'passivation'. Next time the data is requested, it will be 'activated' which means that data will be brought back to memory and removed from the persistent store. This gives you the ability to 'overflow' to disk, similar to swapping in an operating system. If false, the cache store contains a copy of the contents in memory, so writes to cache result in cache store writes. This essentially gives you a 'write-through' configuration. Defaults to false.
        </td>
</tr>
</table>
</div>
</div>
<div class="element">
<h3 class="heading">versioning?</h3>
<div class="content">
<p>
            Controls whether entries are versioned.  Versioning is necessary, for example, when using optimistic transactions in a clustered environment, to be able to perform write-skew checks.
          </p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>scheme</td>
<td>
<table class="enumeration">
<tr>
<td title="&#10;            A simple versioning scheme that is cluster-aware&#10;          ">SIMPLE</td>
<td>
            A simple versioning scheme that is cluster-aware
          </td>
</tr>
<tr>
<td title="&#10;            Don't version entries&#10;          ">NONE</td>
<td>
            Don't version entries
          </td>
</tr>
</table>
</td>
<td>NONE</td>
<td>
          The scheme to use when versioning entries. Can be either SIMPLE or NONE. Defaults to NONE
        </td>
</tr>
</table>
</div>
</div>
<div class="element">
<h3 class="heading">data-container?</h3>
<div class="content">
<p>
            Controls the data container for the cache.
          </p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>class</td>
<td>string</td>
<td/>
<td>
          DEPRECATED: this is to be removed in a future release
          Fully qualified class name of the data container to use
        </td>
</tr>
<tr>
<td>key-equivalence</td>
<td>string</td>
<td/>
<td>
          Fully qualified class name of the Equivalence class to use
          for keys stored in the cache, which provides with custom
          ways to compare cached keys
        </td>
</tr>
<tr>
<td>value-equivalence</td>
<td>string</td>
<td/>
<td>
          Fully qualified class name of the Equivalence class to use
          for values stored in the cache, which provides with custom
          ways to compare cached values
        </td>
</tr>
</table>
<div class="element">
<h3 class="heading">property*</h3>
<div class="content">
<p>Properties passed to the data container</p>
</div>
</div>
</div>
</div>
<div class="element">
<h3 class="heading">modules?</h3>
<div class="content">
<p>
            This element contains configuration options for additional modules which affect cache configuration
          </p>
</div>
</div>
<div class="element">
<h3 class="heading">indexing?</h3>
<div class="content">
<p>
            Defines indexing options for cache
          </p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>index</td>
<td>
<table class="enumeration">
<tr>
<td title="Do not index data. This is the default.">NONE</td>
<td>Do not index data. This is the default.</td>
</tr>
<tr>
<td title="Only index changes made locally, ignoring remote changes. This is useful if indexes are shared across a cluster to prevent redundant indexing of updates.">LOCAL</td>
<td>Only index changes made locally, ignoring remote changes. This is useful if indexes are shared across a cluster to prevent redundant indexing of updates.</td>
</tr>
<tr>
<td title="Index all data">ALL</td>
<td>Index all data</td>
</tr>
</table>
</td>
<td>NONE</td>
<td>The indexing mode of the cache. Defaults to NONE.</td>
</tr>
<tr>
<td>auto-config</td>
<td>boolean</td>
<td>false</td>
<td>Whether or not to apply automatic index configuration based on cache type</td>
</tr>
</table>
<div class="element">
<h3 class="heading">indexed-entities?</h3>
<div class="content">
<p>Defines the indexed entity classes</p>
<div class="element">
<h3 class="heading">indexed-entity*</h3>
<div class="content">
<p>Indexed entity class name</p>
</div>
</div>
</div>
</div>
<div class="element">
<h3 class="heading">property*</h3>
<div class="content">
<p>Property to pass on to the indexing system</p>
</div>
</div>
</div>
</div>
<div class="element">
<h3 class="heading">custom-interceptors?</h3>
<div class="content">
<p>Configures custom interceptors to be added to the cache.</p>
<div class="element">
<h3 class="heading">interceptor*</h3>
<div class="content">
<p/>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>after</td>
<td>string</td>
<td/>
<td>Dictates that the custom interceptor appears immediately after the specified interceptor. If the specified interceptor is not found in the interceptor chain, a ConfigurationException will be thrown when the cache starts.</td>
</tr>
<tr>
<td>before</td>
<td>string</td>
<td/>
<td>Dictates that the custom interceptor appears immediately before the specified interceptor. If the specified interceptor is not found in the interceptor chain, a ConfigurationException will be thrown when the cache starts.</td>
</tr>
<tr>
<td>class</td>
<td>string</td>
<td/>
<td>A fully qualified class name of the new custom interceptor to add to the configuration.</td>
</tr>
<tr>
<td>index</td>
<td>int</td>
<td/>
<td>Specifies a position in the interceptor chain to place the new interceptor. The index starts at 0 and goes up to the number of interceptors in a given configuration. A ConfigurationException is thrown if the index is less than 0 or greater than the maximum number of interceptors in the chain.</td>
</tr>
<tr>
<td>position</td>
<td>string</td>
<td/>
<td>Specifies a position where to place the new interceptor. Allowed values are FIRST, LAST, and OTHER_THAN_FIRST_OR_LAST</td>
</tr>
</table>
<div class="element">
<h3 class="heading">property?</h3>
<div class="content">
<p/>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="element">
<h3 class="heading">security?</h3>
<div class="content">
<p>Configures cache-level security.</p>
<div class="element">
<h3 class="heading">authorization?</h3>
<div class="content">
<p>
            Configures authorization for this cache.
          </p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>enabled</td>
<td>boolean</td>
<td>true</td>
<td>
                Enables authorization checks for this cache. Defaults to true if the authorization element is present.
              </td>
</tr>
<tr>
<td>roles</td>
<td/>
<td/>
<td>
                Sets the valid roles required to access this cache.
              </td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
        <div class="element">
<h3 class="heading">local-cache-configuration</h3>
<div class="content">
<p>Defines a LOCAL mode cache configuration.</p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>simple-cache</td>
<td>
<span class="error">FIXME</span>
</td>
<td>false</td>
<td>
              This cache will be using optimized (faster) implementation that does not support transactions/invocation batching, persistence, custom interceptors, indexing, store-as-binary or compatibility. Also, this type of cache does not support Map-Reduce jobs or Distributed Executor framework.
            </td>
</tr>
</table>
<div>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>name</td>
<td>ID</td>
<td/>
<td>Uniquely identifies this cache within its cache container.</td>
</tr>
<tr>
<td>configuration</td>
<td>IDREF</td>
<td/>
<td>The name of the cache configuration which this configuration inherits from.</td>
</tr>
<tr>
<td>start</td>
<td>
<span class="error">FIXME</span>
</td>
<td/>
<td>Unused XML attribute</td>
</tr>
<tr>
<td>jndi-name</td>
<td>string</td>
<td/>
<td>Unused XML attribute</td>
</tr>
<tr>
<td>module</td>
<td>string</td>
<td/>
<td>Unused XML attribute</td>
</tr>
<tr>
<td>statistics</td>
<td>boolean</td>
<td>true</td>
<td>Determines whether or not the cache should collect statistics.  Keep disabled for optimal performance.</td>
</tr>
<tr>
<td>statistics-available</td>
<td>boolean</td>
<td>true</td>
<td>If set to false, statistics gathering cannot be enabled during runtime. Keep disabled for optimal performance.</td>
</tr>
<tr>
<td>deadlock-detection-spin</td>
<td>long</td>
<td>100</td>
<td>
          Time period that determines how often is lock acquisition attempted within maximum time allowed to acquire a particular lock. Defaults to 100ms.
        </td>
</tr>
<tr>
<td>unreliable-return-values</td>
<td>boolean</td>
<td>false</td>
<td>
          Specifies whether Infinispan is allowed to disregard the Map contract when providing return values for org.infinispan.Cache#put(Object, Object) and org.infinispan.Cache#remove(Object) methods.
        </td>
</tr>
</table>
<div class="element">
<h3 class="heading">backups?</h3>
<div class="content">
<p>The state transfer configuration for distribution and replicated caches.</p>
<div class="element">
<h3 class="heading">backup*</h3>
<div class="content">
<p>Configures a specific site where this cache backups data.</p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>site</td>
<td>string</td>
<td/>
<td>Name of the remote site where this cache backups data.</td>
</tr>
<tr>
<td>strategy</td>
<td>
<table class="enumeration">
<tr>
<td title="Enables asynchronous mode.">ASYNC</td>
<td>Enables asynchronous mode.</td>
</tr>
<tr>
<td title="Enables synchronous mode.">SYNC</td>
<td>Enables synchronous mode.</td>
</tr>
</table>
</td>
<td>ASYNC</td>
<td>The strategy used for backing up data: "SYNC" or "ASYNC". Defaults to "ASYNC"</td>
</tr>
<tr>
<td>failure-policy</td>
<td>
<table class="enumeration">
<tr>
<td title="Ignore backup failures.">IGNORE</td>
<td>Ignore backup failures.</td>
</tr>
<tr>
<td title="Warn of backup failures.">WARN</td>
<td>Warn of backup failures.</td>
</tr>
<tr>
<td title="Fail local operations when a backup failure occurs.">FAIL</td>
<td>Fail local operations when a backup failure occurs.</td>
</tr>
<tr>
<td title="Invoke a user-specified failure policy (set via the failure-policy-class attribute)">CUSTOM</td>
<td>Invoke a user-specified failure policy (set via the failure-policy-class attribute)</td>
</tr>
</table>
</td>
<td>WARN</td>
<td>Decides what the system would do in case of failure during backup. Defaults to "WARN"</td>
</tr>
<tr>
<td>timeout</td>
<td>long</td>
<td>10000</td>
<td>The timeout(millis) to be used when backing up data remotely. Defaults to 10 secs.</td>
</tr>
<tr>
<td>enabled</td>
<td>boolean</td>
<td>true</td>
<td>If 'false' then no data is backed up to this site. Defaults to 'true'.</td>
</tr>
<tr>
<td>two-phase-commit</td>
<td>boolean</td>
<td>false</td>
<td>
          Configures whether the replication happens in a 1PC or 2PC when using SYNC backup strategy. Defaults to "false".
          CacheConfigurationException is thrown when used with ASYNC backup strategy.
        </td>
</tr>
<tr>
<td>failure-policy-class</td>
<td>string</td>
<td/>
<td>
          If the 'backupFailurePolicy' is set to 'CUSTOM' then this attribute is
          required and should
          contain the fully qualified name of a class implementing
          org.infinispan.xsite.CustomFailurePolicy.
        </td>
</tr>
</table>
<div class="element">
<h3 class="heading">take-offline?</h3>
<div class="content">
<p>Determines whether this backup is taken offline (ignored) after a certain number of tries.</p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>after-failures</td>
<td>int</td>
<td>0</td>
<td>The number of failed request operations after which this site should be taken offline. Defaults to 0 (never). A negative value would mean that the site will be taken offline after 'min-wait'.</td>
</tr>
<tr>
<td>min-wait</td>
<td>long</td>
<td>0</td>
<td>The minimal number of millis to wait before taking this site offline, even in the case 'after-failures' is reached. If smaller or equal to 0, then only 'after-failures' is considered.</td>
</tr>
</table>
</div>
</div>
<div class="element">
<h3 class="heading">state-transfer?</h3>
<div class="content">
<p>
            Configures the properties needed to transfer the state for this site.
          </p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>chunk-size</td>
<td>int</td>
<td>512</td>
<td>
                If &gt; 0, the state will be transferred in batches of {@code chunkSize} cache entries.
                If &lt;= 0, the state will be transferred in all at once. Not recommended. Defaults to 512.
              </td>
</tr>
<tr>
<td>timeout</td>
<td>long</td>
<td>1200000</td>
<td>
                The time (in milliseconds) to wait for the backup site acknowledge the state chunk
                received and applied. Default value is 20 min.
              </td>
</tr>
<tr>
<td>max-retries</td>
<td>int</td>
<td>30</td>
<td>
                The maximum number of retries when a push state command fails. A value &lt;= 0 (zero) mean that
                the command will not retry. Default value is 30.
              </td>
</tr>
<tr>
<td>wait-time</td>
<td>long</td>
<td>2000</td>
<td>
                The waiting time (in milliseconds) between each retry. The value should be &gt; 0 (zero). Default
                value is 2 seconds.
              </td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="element">
<h3 class="heading">backup-for?</h3>
<div class="content">
<p>
            Configures this cache as a backup for a remote cache.
          </p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>remote-cache</td>
<td>string</td>
<td/>
<td>
                The name of the remote cache that backups data here.
              </td>
</tr>
<tr>
<td>remote-site</td>
<td>string</td>
<td/>
<td>
                The name of the remote site containing the cache that backups data here.
              </td>
</tr>
</table>
</div>
</div>
<div class="element">
<h3 class="heading">locking?</h3>
<div class="content">
<p>The locking configuration of the cache.</p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>isolation</td>
<td>
<table class="enumeration">
<tr>
<td title="No locking isolation will be performed. This is only valid in local mode. In clustered mode, READ_COMMITTED will be used instead.">NONE</td>
<td>No locking isolation will be performed. This is only valid in local mode. In clustered mode, READ_COMMITTED will be used instead.</td>
</tr>
<tr>
<td title="Unsupported. Actually configures READ_COMMITTED">READ_UNCOMMITTED</td>
<td>Unsupported. Actually configures READ_COMMITTED</td>
</tr>
<tr>
<td title="Read committed is an isolation level that guarantees that any data read is committed at the moment it is read. However, depending on the outcome of other transactions, successive reads may return different results">READ_COMMITTED</td>
<td>Read committed is an isolation level that guarantees that any data read is committed at the moment it is read. However, depending on the outcome of other transactions, successive reads may return different results</td>
</tr>
<tr>
<td title="Repeatable read is an isolation level that guarantees that any data read is committed at the moment it is read and that, within a transaction, successive reads will always return the same data.">REPEATABLE_READ</td>
<td>Repeatable read is an isolation level that guarantees that any data read is committed at the moment it is read and that, within a transaction, successive reads will always return the same data.</td>
</tr>
<tr>
<td title="Unsupported. Actually configures REPEATABLE_READ">SERIALIZABLE</td>
<td>Unsupported. Actually configures REPEATABLE_READ</td>
</tr>
</table>
</td>
<td>READ_COMMITTED</td>
<td>Sets the cache locking isolation level. Infinispan only supports READ_COMMITTED or REPEATABLE_READ isolation level.</td>
</tr>
<tr>
<td>striping</td>
<td>boolean</td>
<td>false</td>
<td>If true, a pool of shared locks is maintained for all entries that need to be locked. Otherwise, a lock is created per entry in the cache. Lock striping helps control memory footprint but may reduce concurrency in the system.</td>
</tr>
<tr>
<td>acquire-timeout</td>
<td>long</td>
<td>10000</td>
<td>Maximum time to attempt a particular lock acquisition.</td>
</tr>
<tr>
<td>concurrency-level</td>
<td>int</td>
<td>32</td>
<td>Concurrency level for lock containers. Adjust this value according to the number of concurrent threads interacting with Infinispan.</td>
</tr>
<tr>
<td>write-skew</td>
<td>boolean</td>
<td>false</td>
<td>
          This setting is only applicable in the case of REPEATABLE_READ. When write skew check is set to false, if the writer at commit time discovers that the working entry and the underlying entry have different versions, the working entry will overwrite the underlying entry. If true, such version conflict - known as a write-skew - will throw an Exception. Defaults to false.
        </td>
</tr>
</table>
</div>
</div>
<div class="element">
<h3 class="heading">transaction?</h3>
<div class="content">
<p>The cache transaction configuration.</p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>mode</td>
<td>
<table class="enumeration">
<tr>
<td title="Cache will not enlist within transactions.">NONE</td>
<td>Cache will not enlist within transactions.</td>
</tr>
<tr>
<td title="Uses batching to group cache operations together.">BATCH</td>
<td>Uses batching to group cache operations together.</td>
</tr>
<tr>
<td title="Cache will enlist within transactions as a javax.transaction.Synchronization">NON_XA</td>
<td>Cache will enlist within transactions as a javax.transaction.Synchronization</td>
</tr>
<tr>
<td title="Cache will enlist within transactions as a javax.transaction.xa.XAResource, without recovery.">NON_DURABLE_XA</td>
<td>Cache will enlist within transactions as a javax.transaction.xa.XAResource, without recovery.</td>
</tr>
<tr>
<td title="Cache will enlist within transactions as a javax.transaction.xa.XAResource, with recovery.">FULL_XA</td>
<td>Cache will enlist within transactions as a javax.transaction.xa.XAResource, with recovery.</td>
</tr>
</table>
</td>
<td>NONE</td>
<td>Sets the cache transaction mode to one of NONE, BATCH, NON_XA, NON_DURABLE_XA, FULL_XA.</td>
</tr>
<tr>
<td>stop-timeout</td>
<td>long</td>
<td>30000</td>
<td>If there are any ongoing transactions when a cache is stopped, Infinispan waits for ongoing remote and local transactions to finish. The amount of time to wait for is defined by the cache stop timeout.</td>
</tr>
<tr>
<td>locking</td>
<td>
<table class="enumeration">
<tr>
<td title="Enables Optimistic locking.">OPTIMISTIC</td>
<td>Enables Optimistic locking.</td>
</tr>
<tr>
<td title="Enables Pessimistic locking.">PESSIMISTIC</td>
<td>Enables Pessimistic locking.</td>
</tr>
</table>
</td>
<td>OPTIMISTIC</td>
<td>The locking mode for this cache, one of OPTIMISTIC or PESSIMISTIC.</td>
</tr>
<tr>
<td>transaction-manager-lookup</td>
<td>string</td>
<td>org.infinispan.transaction.lookup.GenericTransactionManagerLookup.GenericTransactionManagerLookup</td>
<td>
          Configure Transaction manager lookup directly using an instance of TransactionManagerLookup. Calling this method marks the cache as transactional.
        </td>
</tr>
<tr>
<td>complete-timeout</td>
<td>long</td>
<td>60000</td>
<td>
          The duration (millis) in which to keep information about the completion of a transaction. Defaults to 60000.
        </td>
</tr>
<tr>
<td>reaper-interval</td>
<td>long</td>
<td>30000</td>
<td>
          The time interval (millis) at which the thread that cleans up transaction completion information kicks in. Defaults to 30000.
        </td>
</tr>
<tr>
<td>auto-commit</td>
<td>boolean</td>
<td>true</td>
<td>
          If the cache is transactional and transactionAutoCommit is enabled then for single operation transactions the user doesn't need to manually start a transaction, but a transactions is injected by the system. Defaults to true.
        </td>
</tr>
<tr>
<td>protocol</td>
<td>
<table class="enumeration">
<tr>
<td title="">DEFAULT</td>
<td/>
</tr>
<tr>
<td title="">TOTAL_ORDER</td>
<td/>
</tr>
</table>
</td>
<td/>
<td>
          Configures the commit protocol to use.
        </td>
</tr>
<tr>
<td>recovery-cache</td>
<td>string</td>
<td>__recoveryInfoCacheName__</td>
<td>
          Sets the name of the cache where recovery related information is held. The cache's default name is "__recoveryInfoCacheName__"
        </td>
</tr>
<tr>
<td>notifications</td>
<td>boolean</td>
<td>true</td>
<td>
          Enables or disables triggering transactional notifications on cache listeners. By default is enabled.
        </td>
</tr>
</table>
</div>
</div>
<div class="element">
<h3 class="heading">eviction?</h3>
<div class="content">
<p>The cache eviction configuration.</p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>strategy</td>
<td>
<table class="enumeration">
<tr>
<td title="Never evict entries. This is the default.">NONE</td>
<td>Never evict entries. This is the default.</td>
</tr>
<tr>
<td title="Actually activates LRU.">UNORDERED</td>
<td>Actually activates LRU.</td>
</tr>
<tr>
<td title="Deprecated. Actually activates LRU.">FIFO</td>
<td>Deprecated. Actually activates LRU.</td>
</tr>
<tr>
<td title="Least-Recently Used policy.">LRU</td>
<td>Least-Recently Used policy.</td>
</tr>
<tr>
<td title="Low Inter-reference Recency Set. An improved version of LRU which uses cache-locality access information to better decide which data to evict.">LIRS</td>
<td>Low Inter-reference Recency Set. An improved version of LRU which uses cache-locality access information to better decide which data to evict.</td>
</tr>
<tr>
<td title="Eviction will be performed manually. Equivalent internally to NONE.">MANUAL</td>
<td>Eviction will be performed manually. Equivalent internally to NONE.</td>
</tr>
</table>
</td>
<td>NONE</td>
<td>Sets the cache eviction strategy. Available options are 'UNORDERED', 'FIFO', 'LRU', 'LIRS' and 'NONE' (to disable eviction).</td>
</tr>
<tr>
<td>max-entries</td>
<td>long</td>
<td>-1</td>
<td>Deprecated since 8.1. Use the size attribute instead.</td>
</tr>
<tr>
<td>thread-policy</td>
<td>
<table class="enumeration">
<tr>
<td title="Fires the eviction events from the same thread which is performing the eviction ">PIGGYBACK</td>
<td>Fires the eviction events from the same thread which is performing the eviction </td>
</tr>
<tr>
<td title="Use the default eviction listener thread policy (PIGGYBACK)">DEFAULT</td>
<td>Use the default eviction listener thread policy (PIGGYBACK)</td>
</tr>
</table>
</td>
<td>DEFAULT</td>
<td>
          Threading policy for eviction. Defaults to using the DEFAULT eviction policy.
        </td>
</tr>
<tr>
<td>type</td>
<td>
<table class="enumeration">
<tr>
<td title="Evicts entries from the cache when a specified count has been set">COUNT</td>
<td>Evicts entries from the cache when a specified count has been set</td>
</tr>
<tr>
<td title="Evicts entries from the cache when a specified memory usage has been reached. Memory usage is computed using an approximation which is tailored for the HotSpot VM. This can only be used when both key and values are stored as byte arrays. To guarantee only byte arrays are stored it is recommended to run with store as binary for both keys and values">MEMORY</td>
<td>Evicts entries from the cache when a specified memory usage has been reached. Memory usage is computed using an approximation which is tailored for the HotSpot VM. This can only be used when both key and values are stored as byte arrays. To guarantee only byte arrays are stored it is recommended to run with store as binary for both keys and values</td>
</tr>
</table>
</td>
<td>COUNT</td>
<td>Specifies whether to use entry count or memory-based approximation to decide when to evict entries.</td>
</tr>
<tr>
<td>size</td>
<td>long</td>
<td>-1</td>
<td>Maximum size to use for eviction. When using the COUNT type, this is the maximum number of entries in a cache instance. When using the MEMORY threshold policy, this is the maximum number of allocated bytes used by a cache's datacontainer. A value of -1 means no limit. This is currently limited to 2^48 - 1 in size.</td>
</tr>
</table>
</div>
</div>
<div class="element">
<h3 class="heading">expiration?</h3>
<div class="content">
<p>The cache expiration configuration.</p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>max-idle</td>
<td>long</td>
<td>-1</td>
<td>Maximum idle time a cache entry will be maintained in the cache, in milliseconds. If the idle time is exceeded, the entry will be expired cluster-wide. -1 means the entries never expire.</td>
</tr>
<tr>
<td>lifespan</td>
<td>long</td>
<td>-1</td>
<td>Maximum lifespan of a cache entry, after which the entry is expired cluster-wide, in milliseconds. -1 means the entries never expire.</td>
</tr>
<tr>
<td>interval</td>
<td>long</td>
<td>60000</td>
<td>Interval (in milliseconds) between subsequent runs to purge expired entries from memory and any cache stores. If you wish to disable the periodic eviction process altogether, set interval to -1.</td>
</tr>
</table>
</div>
</div>
<div class="element">
<h3 class="heading">compatibility?</h3>
<div class="content">
<p>The cache compatibility mode configuration.</p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>marshaller</td>
<td>string</td>
<td/>
<td>A marshaller to use for compatibility conversions.</td>
</tr>
</table>
</div>
</div>
<div class="element">
<h3 class="heading">store-as-binary?</h3>
<div class="content">
<p>Configures the cache to store data in binary format.</p>
        Controls whether when stored in memory, keys and values are stored as references to their original objects, or in a serialized, binary format.  There are benefits to both approaches, but often if used in a clustered mode, storing objects as binary means that the cost of serialization happens early on, and can be amortized.  Further, deserialization costs are incurred lazily which improves throughput. It is possible to control this on a fine-grained basis: you can choose to just store keys or values as binary, or both.
      <table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>keys</td>
<td>boolean</td>
<td>true</td>
<td>
          Specify whether keys are stored as binary or not. Enabled by default if the "enabled" attribute is set to true.
        </td>
</tr>
<tr>
<td>values</td>
<td>boolean</td>
<td>true</td>
<td>
          Specify whether values are stored as binary or not. Enabled by default if the "enabled" attribute is set to true.
        </td>
</tr>
</table>
</div>
</div>
<div class="element">
<h3 class="heading">persistence?</h3>
<div class="content">
<p>Configures the cache's persistence layer.</p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>passivation</td>
<td>boolean</td>
<td>false</td>
<td>
          If true, data is only written to the cache store when it is evicted from memory, a phenomenon known as 'passivation'. Next time the data is requested, it will be 'activated' which means that data will be brought back to memory and removed from the persistent store. This gives you the ability to 'overflow' to disk, similar to swapping in an operating system. If false, the cache store contains a copy of the contents in memory, so writes to cache result in cache store writes. This essentially gives you a 'write-through' configuration. Defaults to false.
        </td>
</tr>
</table>
</div>
</div>
<div class="element">
<h3 class="heading">versioning?</h3>
<div class="content">
<p>
            Controls whether entries are versioned.  Versioning is necessary, for example, when using optimistic transactions in a clustered environment, to be able to perform write-skew checks.
          </p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>scheme</td>
<td>
<table class="enumeration">
<tr>
<td title="&#10;            A simple versioning scheme that is cluster-aware&#10;          ">SIMPLE</td>
<td>
            A simple versioning scheme that is cluster-aware
          </td>
</tr>
<tr>
<td title="&#10;            Don't version entries&#10;          ">NONE</td>
<td>
            Don't version entries
          </td>
</tr>
</table>
</td>
<td>NONE</td>
<td>
          The scheme to use when versioning entries. Can be either SIMPLE or NONE. Defaults to NONE
        </td>
</tr>
</table>
</div>
</div>
<div class="element">
<h3 class="heading">data-container?</h3>
<div class="content">
<p>
            Controls the data container for the cache.
          </p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>class</td>
<td>string</td>
<td/>
<td>
          DEPRECATED: this is to be removed in a future release
          Fully qualified class name of the data container to use
        </td>
</tr>
<tr>
<td>key-equivalence</td>
<td>string</td>
<td/>
<td>
          Fully qualified class name of the Equivalence class to use
          for keys stored in the cache, which provides with custom
          ways to compare cached keys
        </td>
</tr>
<tr>
<td>value-equivalence</td>
<td>string</td>
<td/>
<td>
          Fully qualified class name of the Equivalence class to use
          for values stored in the cache, which provides with custom
          ways to compare cached values
        </td>
</tr>
</table>
<div class="element">
<h3 class="heading">property*</h3>
<div class="content">
<p>Properties passed to the data container</p>
</div>
</div>
</div>
</div>
<div class="element">
<h3 class="heading">modules?</h3>
<div class="content">
<p>
            This element contains configuration options for additional modules which affect cache configuration
          </p>
</div>
</div>
<div class="element">
<h3 class="heading">indexing?</h3>
<div class="content">
<p>
            Defines indexing options for cache
          </p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>index</td>
<td>
<table class="enumeration">
<tr>
<td title="Do not index data. This is the default.">NONE</td>
<td>Do not index data. This is the default.</td>
</tr>
<tr>
<td title="Only index changes made locally, ignoring remote changes. This is useful if indexes are shared across a cluster to prevent redundant indexing of updates.">LOCAL</td>
<td>Only index changes made locally, ignoring remote changes. This is useful if indexes are shared across a cluster to prevent redundant indexing of updates.</td>
</tr>
<tr>
<td title="Index all data">ALL</td>
<td>Index all data</td>
</tr>
</table>
</td>
<td>NONE</td>
<td>The indexing mode of the cache. Defaults to NONE.</td>
</tr>
<tr>
<td>auto-config</td>
<td>boolean</td>
<td>false</td>
<td>Whether or not to apply automatic index configuration based on cache type</td>
</tr>
</table>
<div class="element">
<h3 class="heading">indexed-entities?</h3>
<div class="content">
<p>Defines the indexed entity classes</p>
<div class="element">
<h3 class="heading">indexed-entity*</h3>
<div class="content">
<p>Indexed entity class name</p>
</div>
</div>
</div>
</div>
<div class="element">
<h3 class="heading">property*</h3>
<div class="content">
<p>Property to pass on to the indexing system</p>
</div>
</div>
</div>
</div>
<div class="element">
<h3 class="heading">custom-interceptors?</h3>
<div class="content">
<p>Configures custom interceptors to be added to the cache.</p>
<div class="element">
<h3 class="heading">interceptor*</h3>
<div class="content">
<p/>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>after</td>
<td>string</td>
<td/>
<td>Dictates that the custom interceptor appears immediately after the specified interceptor. If the specified interceptor is not found in the interceptor chain, a ConfigurationException will be thrown when the cache starts.</td>
</tr>
<tr>
<td>before</td>
<td>string</td>
<td/>
<td>Dictates that the custom interceptor appears immediately before the specified interceptor. If the specified interceptor is not found in the interceptor chain, a ConfigurationException will be thrown when the cache starts.</td>
</tr>
<tr>
<td>class</td>
<td>string</td>
<td/>
<td>A fully qualified class name of the new custom interceptor to add to the configuration.</td>
</tr>
<tr>
<td>index</td>
<td>int</td>
<td/>
<td>Specifies a position in the interceptor chain to place the new interceptor. The index starts at 0 and goes up to the number of interceptors in a given configuration. A ConfigurationException is thrown if the index is less than 0 or greater than the maximum number of interceptors in the chain.</td>
</tr>
<tr>
<td>position</td>
<td>string</td>
<td/>
<td>Specifies a position where to place the new interceptor. Allowed values are FIRST, LAST, and OTHER_THAN_FIRST_OR_LAST</td>
</tr>
</table>
<div class="element">
<h3 class="heading">property?</h3>
<div class="content">
<p/>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="element">
<h3 class="heading">security?</h3>
<div class="content">
<p>Configures cache-level security.</p>
<div class="element">
<h3 class="heading">authorization?</h3>
<div class="content">
<p>
            Configures authorization for this cache.
          </p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>enabled</td>
<td>boolean</td>
<td>true</td>
<td>
                Enables authorization checks for this cache. Defaults to true if the authorization element is present.
              </td>
</tr>
<tr>
<td>roles</td>
<td/>
<td/>
<td>
                Sets the valid roles required to access this cache.
              </td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
        <div class="element">
<h3 class="heading">replicated-cache</h3>
<div class="content">
<p>Defines a REPL_* mode cache.</p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>segments</td>
<td>int</td>
<td>256</td>
<td>Number of hash space segments (per cluster). The default value is 256, and should be at least 20 * cluster size.
            </td>
</tr>
<tr>
<td>consistent-hash-factory</td>
<td>string</td>
<td/>
<td>
              The factory to use for generating the consistent hash.
              Must implement `org.infinispan.distribution.ch.ConsistentHashFactory`.
              E.g. `org.infinispan.distribution.ch.impl.SyncConsistentHashFactory` can be used to guarantee
              that multiple distributed caches use exactly the same consistent hash, which for performance
              reasons is not guaranteed by the default consistent hash factory instance used.
            </td>
</tr>
<tr>
<td>key-partitioner</td>
<td>string</td>
<td/>
<td>
              The name of the key partitioner class.
              Must implement `org.infinispan.distribution.ch.KeyPartitioner`.
              A custom key partitioner can be used as an alternative to grouping, to guarantee that some keys
              are located in the same segment (and thus their primary owner is the same node).
              Since 8.2.
            </td>
</tr>
</table>
<div class="element">
<h3 class="heading">state-transfer?</h3>
<div class="content">
<p>The state transfer configuration for distribution and replicated caches.</p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>enabled</td>
<td>boolean</td>
<td>true</td>
<td>If enabled, this will cause the cache to ask neighboring caches for state when it starts up, so the cache starts 'warm', although it will impact startup time.</td>
</tr>
<tr>
<td>timeout</td>
<td>long</td>
<td>240000</td>
<td>The maximum amount of time (ms) to wait for state from neighboring caches, before throwing an exception and aborting startup.</td>
</tr>
<tr>
<td>chunk-size</td>
<td>integer</td>
<td>512</td>
<td>The number of cache entries to batch in each transfer.</td>
</tr>
<tr>
<td>await-initial-transfer</td>
<td>boolean</td>
<td>true</td>
<td>If enabled, this will cause the cache to wait for initial state transfer to complete before responding to requests.</td>
</tr>
</table>
</div>
</div>
<div>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>mode</td>
<td>
<table class="enumeration">
<tr>
<td title="Enables asynchronous mode.">ASYNC</td>
<td>Enables asynchronous mode.</td>
</tr>
<tr>
<td title="Enables synchronous mode.">SYNC</td>
<td>Enables synchronous mode.</td>
</tr>
</table>
</td>
<td/>
<td>Sets the clustered cache mode, ASYNC for asynchronous operation, or SYNC for synchronous operation.</td>
</tr>
<tr>
<td>queue-size</td>
<td>int</td>
<td>0</td>
<td>Deprecated. In ASYNC mode, this attribute can be used to trigger flushing of the queue when it reaches a specific threshold. A value of 0 (the default) disables the replication queue.</td>
</tr>
<tr>
<td>queue-flush-interval</td>
<td>long</td>
<td>10</td>
<td>Deprecated. In ASYNC mode, this attribute controls how often the asynchronous thread used to flush the replication queue runs. This should be a positive integer which represents thread wakeup time in milliseconds.</td>
</tr>
<tr>
<td>remote-timeout</td>
<td>long</td>
<td>15000</td>
<td>In SYNC mode, the timeout (in ms) used to wait for an acknowledgment when making a remote call, after which the call is aborted and an exception is thrown.</td>
</tr>
</table>
<div class="element">
<h3 class="heading">partition-handling?</h3>
<div class="content">
<p>
                   Configures the way this cache reacts to node crashes and split brains.
                </p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>enabled</td>
<td>boolean</td>
<td/>
<td>
                         Enable/disable the partition handling functionality. Defaults to false.
                      </td>
</tr>
</table>
</div>
</div>
<div>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>name</td>
<td>ID</td>
<td/>
<td>Uniquely identifies this cache within its cache container.</td>
</tr>
<tr>
<td>configuration</td>
<td>IDREF</td>
<td/>
<td>The name of the cache configuration which this configuration inherits from.</td>
</tr>
<tr>
<td>start</td>
<td>
<span class="error">FIXME</span>
</td>
<td/>
<td>Unused XML attribute</td>
</tr>
<tr>
<td>jndi-name</td>
<td>string</td>
<td/>
<td>Unused XML attribute</td>
</tr>
<tr>
<td>module</td>
<td>string</td>
<td/>
<td>Unused XML attribute</td>
</tr>
<tr>
<td>statistics</td>
<td>boolean</td>
<td>true</td>
<td>Determines whether or not the cache should collect statistics.  Keep disabled for optimal performance.</td>
</tr>
<tr>
<td>statistics-available</td>
<td>boolean</td>
<td>true</td>
<td>If set to false, statistics gathering cannot be enabled during runtime. Keep disabled for optimal performance.</td>
</tr>
<tr>
<td>deadlock-detection-spin</td>
<td>long</td>
<td>100</td>
<td>
          Time period that determines how often is lock acquisition attempted within maximum time allowed to acquire a particular lock. Defaults to 100ms.
        </td>
</tr>
<tr>
<td>unreliable-return-values</td>
<td>boolean</td>
<td>false</td>
<td>
          Specifies whether Infinispan is allowed to disregard the Map contract when providing return values for org.infinispan.Cache#put(Object, Object) and org.infinispan.Cache#remove(Object) methods.
        </td>
</tr>
</table>
<div class="element">
<h3 class="heading">backups?</h3>
<div class="content">
<p>The state transfer configuration for distribution and replicated caches.</p>
<div class="element">
<h3 class="heading">backup*</h3>
<div class="content">
<p>Configures a specific site where this cache backups data.</p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>site</td>
<td>string</td>
<td/>
<td>Name of the remote site where this cache backups data.</td>
</tr>
<tr>
<td>strategy</td>
<td>
<table class="enumeration">
<tr>
<td title="Enables asynchronous mode.">ASYNC</td>
<td>Enables asynchronous mode.</td>
</tr>
<tr>
<td title="Enables synchronous mode.">SYNC</td>
<td>Enables synchronous mode.</td>
</tr>
</table>
</td>
<td>ASYNC</td>
<td>The strategy used for backing up data: "SYNC" or "ASYNC". Defaults to "ASYNC"</td>
</tr>
<tr>
<td>failure-policy</td>
<td>
<table class="enumeration">
<tr>
<td title="Ignore backup failures.">IGNORE</td>
<td>Ignore backup failures.</td>
</tr>
<tr>
<td title="Warn of backup failures.">WARN</td>
<td>Warn of backup failures.</td>
</tr>
<tr>
<td title="Fail local operations when a backup failure occurs.">FAIL</td>
<td>Fail local operations when a backup failure occurs.</td>
</tr>
<tr>
<td title="Invoke a user-specified failure policy (set via the failure-policy-class attribute)">CUSTOM</td>
<td>Invoke a user-specified failure policy (set via the failure-policy-class attribute)</td>
</tr>
</table>
</td>
<td>WARN</td>
<td>Decides what the system would do in case of failure during backup. Defaults to "WARN"</td>
</tr>
<tr>
<td>timeout</td>
<td>long</td>
<td>10000</td>
<td>The timeout(millis) to be used when backing up data remotely. Defaults to 10 secs.</td>
</tr>
<tr>
<td>enabled</td>
<td>boolean</td>
<td>true</td>
<td>If 'false' then no data is backed up to this site. Defaults to 'true'.</td>
</tr>
<tr>
<td>two-phase-commit</td>
<td>boolean</td>
<td>false</td>
<td>
          Configures whether the replication happens in a 1PC or 2PC when using SYNC backup strategy. Defaults to "false".
          CacheConfigurationException is thrown when used with ASYNC backup strategy.
        </td>
</tr>
<tr>
<td>failure-policy-class</td>
<td>string</td>
<td/>
<td>
          If the 'backupFailurePolicy' is set to 'CUSTOM' then this attribute is
          required and should
          contain the fully qualified name of a class implementing
          org.infinispan.xsite.CustomFailurePolicy.
        </td>
</tr>
</table>
<div class="element">
<h3 class="heading">take-offline?</h3>
<div class="content">
<p>Determines whether this backup is taken offline (ignored) after a certain number of tries.</p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>after-failures</td>
<td>int</td>
<td>0</td>
<td>The number of failed request operations after which this site should be taken offline. Defaults to 0 (never). A negative value would mean that the site will be taken offline after 'min-wait'.</td>
</tr>
<tr>
<td>min-wait</td>
<td>long</td>
<td>0</td>
<td>The minimal number of millis to wait before taking this site offline, even in the case 'after-failures' is reached. If smaller or equal to 0, then only 'after-failures' is considered.</td>
</tr>
</table>
</div>
</div>
<div class="element">
<h3 class="heading">state-transfer?</h3>
<div class="content">
<p>
            Configures the properties needed to transfer the state for this site.
          </p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>chunk-size</td>
<td>int</td>
<td>512</td>
<td>
                If &gt; 0, the state will be transferred in batches of {@code chunkSize} cache entries.
                If &lt;= 0, the state will be transferred in all at once. Not recommended. Defaults to 512.
              </td>
</tr>
<tr>
<td>timeout</td>
<td>long</td>
<td>1200000</td>
<td>
                The time (in milliseconds) to wait for the backup site acknowledge the state chunk
                received and applied. Default value is 20 min.
              </td>
</tr>
<tr>
<td>max-retries</td>
<td>int</td>
<td>30</td>
<td>
                The maximum number of retries when a push state command fails. A value &lt;= 0 (zero) mean that
                the command will not retry. Default value is 30.
              </td>
</tr>
<tr>
<td>wait-time</td>
<td>long</td>
<td>2000</td>
<td>
                The waiting time (in milliseconds) between each retry. The value should be &gt; 0 (zero). Default
                value is 2 seconds.
              </td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="element">
<h3 class="heading">backup-for?</h3>
<div class="content">
<p>
            Configures this cache as a backup for a remote cache.
          </p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>remote-cache</td>
<td>string</td>
<td/>
<td>
                The name of the remote cache that backups data here.
              </td>
</tr>
<tr>
<td>remote-site</td>
<td>string</td>
<td/>
<td>
                The name of the remote site containing the cache that backups data here.
              </td>
</tr>
</table>
</div>
</div>
<div class="element">
<h3 class="heading">locking?</h3>
<div class="content">
<p>The locking configuration of the cache.</p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>isolation</td>
<td>
<table class="enumeration">
<tr>
<td title="No locking isolation will be performed. This is only valid in local mode. In clustered mode, READ_COMMITTED will be used instead.">NONE</td>
<td>No locking isolation will be performed. This is only valid in local mode. In clustered mode, READ_COMMITTED will be used instead.</td>
</tr>
<tr>
<td title="Unsupported. Actually configures READ_COMMITTED">READ_UNCOMMITTED</td>
<td>Unsupported. Actually configures READ_COMMITTED</td>
</tr>
<tr>
<td title="Read committed is an isolation level that guarantees that any data read is committed at the moment it is read. However, depending on the outcome of other transactions, successive reads may return different results">READ_COMMITTED</td>
<td>Read committed is an isolation level that guarantees that any data read is committed at the moment it is read. However, depending on the outcome of other transactions, successive reads may return different results</td>
</tr>
<tr>
<td title="Repeatable read is an isolation level that guarantees that any data read is committed at the moment it is read and that, within a transaction, successive reads will always return the same data.">REPEATABLE_READ</td>
<td>Repeatable read is an isolation level that guarantees that any data read is committed at the moment it is read and that, within a transaction, successive reads will always return the same data.</td>
</tr>
<tr>
<td title="Unsupported. Actually configures REPEATABLE_READ">SERIALIZABLE</td>
<td>Unsupported. Actually configures REPEATABLE_READ</td>
</tr>
</table>
</td>
<td>READ_COMMITTED</td>
<td>Sets the cache locking isolation level. Infinispan only supports READ_COMMITTED or REPEATABLE_READ isolation level.</td>
</tr>
<tr>
<td>striping</td>
<td>boolean</td>
<td>false</td>
<td>If true, a pool of shared locks is maintained for all entries that need to be locked. Otherwise, a lock is created per entry in the cache. Lock striping helps control memory footprint but may reduce concurrency in the system.</td>
</tr>
<tr>
<td>acquire-timeout</td>
<td>long</td>
<td>10000</td>
<td>Maximum time to attempt a particular lock acquisition.</td>
</tr>
<tr>
<td>concurrency-level</td>
<td>int</td>
<td>32</td>
<td>Concurrency level for lock containers. Adjust this value according to the number of concurrent threads interacting with Infinispan.</td>
</tr>
<tr>
<td>write-skew</td>
<td>boolean</td>
<td>false</td>
<td>
          This setting is only applicable in the case of REPEATABLE_READ. When write skew check is set to false, if the writer at commit time discovers that the working entry and the underlying entry have different versions, the working entry will overwrite the underlying entry. If true, such version conflict - known as a write-skew - will throw an Exception. Defaults to false.
        </td>
</tr>
</table>
</div>
</div>
<div class="element">
<h3 class="heading">transaction?</h3>
<div class="content">
<p>The cache transaction configuration.</p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>mode</td>
<td>
<table class="enumeration">
<tr>
<td title="Cache will not enlist within transactions.">NONE</td>
<td>Cache will not enlist within transactions.</td>
</tr>
<tr>
<td title="Uses batching to group cache operations together.">BATCH</td>
<td>Uses batching to group cache operations together.</td>
</tr>
<tr>
<td title="Cache will enlist within transactions as a javax.transaction.Synchronization">NON_XA</td>
<td>Cache will enlist within transactions as a javax.transaction.Synchronization</td>
</tr>
<tr>
<td title="Cache will enlist within transactions as a javax.transaction.xa.XAResource, without recovery.">NON_DURABLE_XA</td>
<td>Cache will enlist within transactions as a javax.transaction.xa.XAResource, without recovery.</td>
</tr>
<tr>
<td title="Cache will enlist within transactions as a javax.transaction.xa.XAResource, with recovery.">FULL_XA</td>
<td>Cache will enlist within transactions as a javax.transaction.xa.XAResource, with recovery.</td>
</tr>
</table>
</td>
<td>NONE</td>
<td>Sets the cache transaction mode to one of NONE, BATCH, NON_XA, NON_DURABLE_XA, FULL_XA.</td>
</tr>
<tr>
<td>stop-timeout</td>
<td>long</td>
<td>30000</td>
<td>If there are any ongoing transactions when a cache is stopped, Infinispan waits for ongoing remote and local transactions to finish. The amount of time to wait for is defined by the cache stop timeout.</td>
</tr>
<tr>
<td>locking</td>
<td>
<table class="enumeration">
<tr>
<td title="Enables Optimistic locking.">OPTIMISTIC</td>
<td>Enables Optimistic locking.</td>
</tr>
<tr>
<td title="Enables Pessimistic locking.">PESSIMISTIC</td>
<td>Enables Pessimistic locking.</td>
</tr>
</table>
</td>
<td>OPTIMISTIC</td>
<td>The locking mode for this cache, one of OPTIMISTIC or PESSIMISTIC.</td>
</tr>
<tr>
<td>transaction-manager-lookup</td>
<td>string</td>
<td>org.infinispan.transaction.lookup.GenericTransactionManagerLookup.GenericTransactionManagerLookup</td>
<td>
          Configure Transaction manager lookup directly using an instance of TransactionManagerLookup. Calling this method marks the cache as transactional.
        </td>
</tr>
<tr>
<td>complete-timeout</td>
<td>long</td>
<td>60000</td>
<td>
          The duration (millis) in which to keep information about the completion of a transaction. Defaults to 60000.
        </td>
</tr>
<tr>
<td>reaper-interval</td>
<td>long</td>
<td>30000</td>
<td>
          The time interval (millis) at which the thread that cleans up transaction completion information kicks in. Defaults to 30000.
        </td>
</tr>
<tr>
<td>auto-commit</td>
<td>boolean</td>
<td>true</td>
<td>
          If the cache is transactional and transactionAutoCommit is enabled then for single operation transactions the user doesn't need to manually start a transaction, but a transactions is injected by the system. Defaults to true.
        </td>
</tr>
<tr>
<td>protocol</td>
<td>
<table class="enumeration">
<tr>
<td title="">DEFAULT</td>
<td/>
</tr>
<tr>
<td title="">TOTAL_ORDER</td>
<td/>
</tr>
</table>
</td>
<td/>
<td>
          Configures the commit protocol to use.
        </td>
</tr>
<tr>
<td>recovery-cache</td>
<td>string</td>
<td>__recoveryInfoCacheName__</td>
<td>
          Sets the name of the cache where recovery related information is held. The cache's default name is "__recoveryInfoCacheName__"
        </td>
</tr>
<tr>
<td>notifications</td>
<td>boolean</td>
<td>true</td>
<td>
          Enables or disables triggering transactional notifications on cache listeners. By default is enabled.
        </td>
</tr>
</table>
</div>
</div>
<div class="element">
<h3 class="heading">eviction?</h3>
<div class="content">
<p>The cache eviction configuration.</p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>strategy</td>
<td>
<table class="enumeration">
<tr>
<td title="Never evict entries. This is the default.">NONE</td>
<td>Never evict entries. This is the default.</td>
</tr>
<tr>
<td title="Actually activates LRU.">UNORDERED</td>
<td>Actually activates LRU.</td>
</tr>
<tr>
<td title="Deprecated. Actually activates LRU.">FIFO</td>
<td>Deprecated. Actually activates LRU.</td>
</tr>
<tr>
<td title="Least-Recently Used policy.">LRU</td>
<td>Least-Recently Used policy.</td>
</tr>
<tr>
<td title="Low Inter-reference Recency Set. An improved version of LRU which uses cache-locality access information to better decide which data to evict.">LIRS</td>
<td>Low Inter-reference Recency Set. An improved version of LRU which uses cache-locality access information to better decide which data to evict.</td>
</tr>
<tr>
<td title="Eviction will be performed manually. Equivalent internally to NONE.">MANUAL</td>
<td>Eviction will be performed manually. Equivalent internally to NONE.</td>
</tr>
</table>
</td>
<td>NONE</td>
<td>Sets the cache eviction strategy. Available options are 'UNORDERED', 'FIFO', 'LRU', 'LIRS' and 'NONE' (to disable eviction).</td>
</tr>
<tr>
<td>max-entries</td>
<td>long</td>
<td>-1</td>
<td>Deprecated since 8.1. Use the size attribute instead.</td>
</tr>
<tr>
<td>thread-policy</td>
<td>
<table class="enumeration">
<tr>
<td title="Fires the eviction events from the same thread which is performing the eviction ">PIGGYBACK</td>
<td>Fires the eviction events from the same thread which is performing the eviction </td>
</tr>
<tr>
<td title="Use the default eviction listener thread policy (PIGGYBACK)">DEFAULT</td>
<td>Use the default eviction listener thread policy (PIGGYBACK)</td>
</tr>
</table>
</td>
<td>DEFAULT</td>
<td>
          Threading policy for eviction. Defaults to using the DEFAULT eviction policy.
        </td>
</tr>
<tr>
<td>type</td>
<td>
<table class="enumeration">
<tr>
<td title="Evicts entries from the cache when a specified count has been set">COUNT</td>
<td>Evicts entries from the cache when a specified count has been set</td>
</tr>
<tr>
<td title="Evicts entries from the cache when a specified memory usage has been reached. Memory usage is computed using an approximation which is tailored for the HotSpot VM. This can only be used when both key and values are stored as byte arrays. To guarantee only byte arrays are stored it is recommended to run with store as binary for both keys and values">MEMORY</td>
<td>Evicts entries from the cache when a specified memory usage has been reached. Memory usage is computed using an approximation which is tailored for the HotSpot VM. This can only be used when both key and values are stored as byte arrays. To guarantee only byte arrays are stored it is recommended to run with store as binary for both keys and values</td>
</tr>
</table>
</td>
<td>COUNT</td>
<td>Specifies whether to use entry count or memory-based approximation to decide when to evict entries.</td>
</tr>
<tr>
<td>size</td>
<td>long</td>
<td>-1</td>
<td>Maximum size to use for eviction. When using the COUNT type, this is the maximum number of entries in a cache instance. When using the MEMORY threshold policy, this is the maximum number of allocated bytes used by a cache's datacontainer. A value of -1 means no limit. This is currently limited to 2^48 - 1 in size.</td>
</tr>
</table>
</div>
</div>
<div class="element">
<h3 class="heading">expiration?</h3>
<div class="content">
<p>The cache expiration configuration.</p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>max-idle</td>
<td>long</td>
<td>-1</td>
<td>Maximum idle time a cache entry will be maintained in the cache, in milliseconds. If the idle time is exceeded, the entry will be expired cluster-wide. -1 means the entries never expire.</td>
</tr>
<tr>
<td>lifespan</td>
<td>long</td>
<td>-1</td>
<td>Maximum lifespan of a cache entry, after which the entry is expired cluster-wide, in milliseconds. -1 means the entries never expire.</td>
</tr>
<tr>
<td>interval</td>
<td>long</td>
<td>60000</td>
<td>Interval (in milliseconds) between subsequent runs to purge expired entries from memory and any cache stores. If you wish to disable the periodic eviction process altogether, set interval to -1.</td>
</tr>
</table>
</div>
</div>
<div class="element">
<h3 class="heading">compatibility?</h3>
<div class="content">
<p>The cache compatibility mode configuration.</p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>marshaller</td>
<td>string</td>
<td/>
<td>A marshaller to use for compatibility conversions.</td>
</tr>
</table>
</div>
</div>
<div class="element">
<h3 class="heading">store-as-binary?</h3>
<div class="content">
<p>Configures the cache to store data in binary format.</p>
        Controls whether when stored in memory, keys and values are stored as references to their original objects, or in a serialized, binary format.  There are benefits to both approaches, but often if used in a clustered mode, storing objects as binary means that the cost of serialization happens early on, and can be amortized.  Further, deserialization costs are incurred lazily which improves throughput. It is possible to control this on a fine-grained basis: you can choose to just store keys or values as binary, or both.
      <table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>keys</td>
<td>boolean</td>
<td>true</td>
<td>
          Specify whether keys are stored as binary or not. Enabled by default if the "enabled" attribute is set to true.
        </td>
</tr>
<tr>
<td>values</td>
<td>boolean</td>
<td>true</td>
<td>
          Specify whether values are stored as binary or not. Enabled by default if the "enabled" attribute is set to true.
        </td>
</tr>
</table>
</div>
</div>
<div class="element">
<h3 class="heading">persistence?</h3>
<div class="content">
<p>Configures the cache's persistence layer.</p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>passivation</td>
<td>boolean</td>
<td>false</td>
<td>
          If true, data is only written to the cache store when it is evicted from memory, a phenomenon known as 'passivation'. Next time the data is requested, it will be 'activated' which means that data will be brought back to memory and removed from the persistent store. This gives you the ability to 'overflow' to disk, similar to swapping in an operating system. If false, the cache store contains a copy of the contents in memory, so writes to cache result in cache store writes. This essentially gives you a 'write-through' configuration. Defaults to false.
        </td>
</tr>
</table>
</div>
</div>
<div class="element">
<h3 class="heading">versioning?</h3>
<div class="content">
<p>
            Controls whether entries are versioned.  Versioning is necessary, for example, when using optimistic transactions in a clustered environment, to be able to perform write-skew checks.
          </p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>scheme</td>
<td>
<table class="enumeration">
<tr>
<td title="&#10;            A simple versioning scheme that is cluster-aware&#10;          ">SIMPLE</td>
<td>
            A simple versioning scheme that is cluster-aware
          </td>
</tr>
<tr>
<td title="&#10;            Don't version entries&#10;          ">NONE</td>
<td>
            Don't version entries
          </td>
</tr>
</table>
</td>
<td>NONE</td>
<td>
          The scheme to use when versioning entries. Can be either SIMPLE or NONE. Defaults to NONE
        </td>
</tr>
</table>
</div>
</div>
<div class="element">
<h3 class="heading">data-container?</h3>
<div class="content">
<p>
            Controls the data container for the cache.
          </p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>class</td>
<td>string</td>
<td/>
<td>
          DEPRECATED: this is to be removed in a future release
          Fully qualified class name of the data container to use
        </td>
</tr>
<tr>
<td>key-equivalence</td>
<td>string</td>
<td/>
<td>
          Fully qualified class name of the Equivalence class to use
          for keys stored in the cache, which provides with custom
          ways to compare cached keys
        </td>
</tr>
<tr>
<td>value-equivalence</td>
<td>string</td>
<td/>
<td>
          Fully qualified class name of the Equivalence class to use
          for values stored in the cache, which provides with custom
          ways to compare cached values
        </td>
</tr>
</table>
<div class="element">
<h3 class="heading">property*</h3>
<div class="content">
<p>Properties passed to the data container</p>
</div>
</div>
</div>
</div>
<div class="element">
<h3 class="heading">modules?</h3>
<div class="content">
<p>
            This element contains configuration options for additional modules which affect cache configuration
          </p>
</div>
</div>
<div class="element">
<h3 class="heading">indexing?</h3>
<div class="content">
<p>
            Defines indexing options for cache
          </p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>index</td>
<td>
<table class="enumeration">
<tr>
<td title="Do not index data. This is the default.">NONE</td>
<td>Do not index data. This is the default.</td>
</tr>
<tr>
<td title="Only index changes made locally, ignoring remote changes. This is useful if indexes are shared across a cluster to prevent redundant indexing of updates.">LOCAL</td>
<td>Only index changes made locally, ignoring remote changes. This is useful if indexes are shared across a cluster to prevent redundant indexing of updates.</td>
</tr>
<tr>
<td title="Index all data">ALL</td>
<td>Index all data</td>
</tr>
</table>
</td>
<td>NONE</td>
<td>The indexing mode of the cache. Defaults to NONE.</td>
</tr>
<tr>
<td>auto-config</td>
<td>boolean</td>
<td>false</td>
<td>Whether or not to apply automatic index configuration based on cache type</td>
</tr>
</table>
<div class="element">
<h3 class="heading">indexed-entities?</h3>
<div class="content">
<p>Defines the indexed entity classes</p>
<div class="element">
<h3 class="heading">indexed-entity*</h3>
<div class="content">
<p>Indexed entity class name</p>
</div>
</div>
</div>
</div>
<div class="element">
<h3 class="heading">property*</h3>
<div class="content">
<p>Property to pass on to the indexing system</p>
</div>
</div>
</div>
</div>
<div class="element">
<h3 class="heading">custom-interceptors?</h3>
<div class="content">
<p>Configures custom interceptors to be added to the cache.</p>
<div class="element">
<h3 class="heading">interceptor*</h3>
<div class="content">
<p/>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>after</td>
<td>string</td>
<td/>
<td>Dictates that the custom interceptor appears immediately after the specified interceptor. If the specified interceptor is not found in the interceptor chain, a ConfigurationException will be thrown when the cache starts.</td>
</tr>
<tr>
<td>before</td>
<td>string</td>
<td/>
<td>Dictates that the custom interceptor appears immediately before the specified interceptor. If the specified interceptor is not found in the interceptor chain, a ConfigurationException will be thrown when the cache starts.</td>
</tr>
<tr>
<td>class</td>
<td>string</td>
<td/>
<td>A fully qualified class name of the new custom interceptor to add to the configuration.</td>
</tr>
<tr>
<td>index</td>
<td>int</td>
<td/>
<td>Specifies a position in the interceptor chain to place the new interceptor. The index starts at 0 and goes up to the number of interceptors in a given configuration. A ConfigurationException is thrown if the index is less than 0 or greater than the maximum number of interceptors in the chain.</td>
</tr>
<tr>
<td>position</td>
<td>string</td>
<td/>
<td>Specifies a position where to place the new interceptor. Allowed values are FIRST, LAST, and OTHER_THAN_FIRST_OR_LAST</td>
</tr>
</table>
<div class="element">
<h3 class="heading">property?</h3>
<div class="content">
<p/>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="element">
<h3 class="heading">security?</h3>
<div class="content">
<p>Configures cache-level security.</p>
<div class="element">
<h3 class="heading">authorization?</h3>
<div class="content">
<p>
            Configures authorization for this cache.
          </p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>enabled</td>
<td>boolean</td>
<td>true</td>
<td>
                Enables authorization checks for this cache. Defaults to true if the authorization element is present.
              </td>
</tr>
<tr>
<td>roles</td>
<td/>
<td/>
<td>
                Sets the valid roles required to access this cache.
              </td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
        <div class="element">
<h3 class="heading">replicated-cache-configuration</h3>
<div class="content">
<p>Defines a REPL_* mode cache configuration.</p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>segments</td>
<td>int</td>
<td>256</td>
<td>Number of hash space segments (per cluster). The default value is 256, and should be at least 20 * cluster size.
            </td>
</tr>
<tr>
<td>consistent-hash-factory</td>
<td>string</td>
<td/>
<td>
              The factory to use for generating the consistent hash.
              Must implement `org.infinispan.distribution.ch.ConsistentHashFactory`.
              E.g. `org.infinispan.distribution.ch.impl.SyncConsistentHashFactory` can be used to guarantee
              that multiple distributed caches use exactly the same consistent hash, which for performance
              reasons is not guaranteed by the default consistent hash factory instance used.
            </td>
</tr>
<tr>
<td>key-partitioner</td>
<td>string</td>
<td/>
<td>
              The name of the key partitioner class.
              Must implement `org.infinispan.distribution.ch.KeyPartitioner`.
              A custom key partitioner can be used as an alternative to grouping, to guarantee that some keys
              are located in the same segment (and thus their primary owner is the same node).
              Since 8.2.
            </td>
</tr>
</table>
<div class="element">
<h3 class="heading">state-transfer?</h3>
<div class="content">
<p>The state transfer configuration for distribution and replicated caches.</p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>enabled</td>
<td>boolean</td>
<td>true</td>
<td>If enabled, this will cause the cache to ask neighboring caches for state when it starts up, so the cache starts 'warm', although it will impact startup time.</td>
</tr>
<tr>
<td>timeout</td>
<td>long</td>
<td>240000</td>
<td>The maximum amount of time (ms) to wait for state from neighboring caches, before throwing an exception and aborting startup.</td>
</tr>
<tr>
<td>chunk-size</td>
<td>integer</td>
<td>512</td>
<td>The number of cache entries to batch in each transfer.</td>
</tr>
<tr>
<td>await-initial-transfer</td>
<td>boolean</td>
<td>true</td>
<td>If enabled, this will cause the cache to wait for initial state transfer to complete before responding to requests.</td>
</tr>
</table>
</div>
</div>
<div>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>mode</td>
<td>
<table class="enumeration">
<tr>
<td title="Enables asynchronous mode.">ASYNC</td>
<td>Enables asynchronous mode.</td>
</tr>
<tr>
<td title="Enables synchronous mode.">SYNC</td>
<td>Enables synchronous mode.</td>
</tr>
</table>
</td>
<td/>
<td>Sets the clustered cache mode, ASYNC for asynchronous operation, or SYNC for synchronous operation.</td>
</tr>
<tr>
<td>queue-size</td>
<td>int</td>
<td>0</td>
<td>Deprecated. In ASYNC mode, this attribute can be used to trigger flushing of the queue when it reaches a specific threshold. A value of 0 (the default) disables the replication queue.</td>
</tr>
<tr>
<td>queue-flush-interval</td>
<td>long</td>
<td>10</td>
<td>Deprecated. In ASYNC mode, this attribute controls how often the asynchronous thread used to flush the replication queue runs. This should be a positive integer which represents thread wakeup time in milliseconds.</td>
</tr>
<tr>
<td>remote-timeout</td>
<td>long</td>
<td>15000</td>
<td>In SYNC mode, the timeout (in ms) used to wait for an acknowledgment when making a remote call, after which the call is aborted and an exception is thrown.</td>
</tr>
</table>
<div class="element">
<h3 class="heading">partition-handling?</h3>
<div class="content">
<p>
                   Configures the way this cache reacts to node crashes and split brains.
                </p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>enabled</td>
<td>boolean</td>
<td/>
<td>
                         Enable/disable the partition handling functionality. Defaults to false.
                      </td>
</tr>
</table>
</div>
</div>
<div>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>name</td>
<td>ID</td>
<td/>
<td>Uniquely identifies this cache within its cache container.</td>
</tr>
<tr>
<td>configuration</td>
<td>IDREF</td>
<td/>
<td>The name of the cache configuration which this configuration inherits from.</td>
</tr>
<tr>
<td>start</td>
<td>
<span class="error">FIXME</span>
</td>
<td/>
<td>Unused XML attribute</td>
</tr>
<tr>
<td>jndi-name</td>
<td>string</td>
<td/>
<td>Unused XML attribute</td>
</tr>
<tr>
<td>module</td>
<td>string</td>
<td/>
<td>Unused XML attribute</td>
</tr>
<tr>
<td>statistics</td>
<td>boolean</td>
<td>true</td>
<td>Determines whether or not the cache should collect statistics.  Keep disabled for optimal performance.</td>
</tr>
<tr>
<td>statistics-available</td>
<td>boolean</td>
<td>true</td>
<td>If set to false, statistics gathering cannot be enabled during runtime. Keep disabled for optimal performance.</td>
</tr>
<tr>
<td>deadlock-detection-spin</td>
<td>long</td>
<td>100</td>
<td>
          Time period that determines how often is lock acquisition attempted within maximum time allowed to acquire a particular lock. Defaults to 100ms.
        </td>
</tr>
<tr>
<td>unreliable-return-values</td>
<td>boolean</td>
<td>false</td>
<td>
          Specifies whether Infinispan is allowed to disregard the Map contract when providing return values for org.infinispan.Cache#put(Object, Object) and org.infinispan.Cache#remove(Object) methods.
        </td>
</tr>
</table>
<div class="element">
<h3 class="heading">backups?</h3>
<div class="content">
<p>The state transfer configuration for distribution and replicated caches.</p>
<div class="element">
<h3 class="heading">backup*</h3>
<div class="content">
<p>Configures a specific site where this cache backups data.</p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>site</td>
<td>string</td>
<td/>
<td>Name of the remote site where this cache backups data.</td>
</tr>
<tr>
<td>strategy</td>
<td>
<table class="enumeration">
<tr>
<td title="Enables asynchronous mode.">ASYNC</td>
<td>Enables asynchronous mode.</td>
</tr>
<tr>
<td title="Enables synchronous mode.">SYNC</td>
<td>Enables synchronous mode.</td>
</tr>
</table>
</td>
<td>ASYNC</td>
<td>The strategy used for backing up data: "SYNC" or "ASYNC". Defaults to "ASYNC"</td>
</tr>
<tr>
<td>failure-policy</td>
<td>
<table class="enumeration">
<tr>
<td title="Ignore backup failures.">IGNORE</td>
<td>Ignore backup failures.</td>
</tr>
<tr>
<td title="Warn of backup failures.">WARN</td>
<td>Warn of backup failures.</td>
</tr>
<tr>
<td title="Fail local operations when a backup failure occurs.">FAIL</td>
<td>Fail local operations when a backup failure occurs.</td>
</tr>
<tr>
<td title="Invoke a user-specified failure policy (set via the failure-policy-class attribute)">CUSTOM</td>
<td>Invoke a user-specified failure policy (set via the failure-policy-class attribute)</td>
</tr>
</table>
</td>
<td>WARN</td>
<td>Decides what the system would do in case of failure during backup. Defaults to "WARN"</td>
</tr>
<tr>
<td>timeout</td>
<td>long</td>
<td>10000</td>
<td>The timeout(millis) to be used when backing up data remotely. Defaults to 10 secs.</td>
</tr>
<tr>
<td>enabled</td>
<td>boolean</td>
<td>true</td>
<td>If 'false' then no data is backed up to this site. Defaults to 'true'.</td>
</tr>
<tr>
<td>two-phase-commit</td>
<td>boolean</td>
<td>false</td>
<td>
          Configures whether the replication happens in a 1PC or 2PC when using SYNC backup strategy. Defaults to "false".
          CacheConfigurationException is thrown when used with ASYNC backup strategy.
        </td>
</tr>
<tr>
<td>failure-policy-class</td>
<td>string</td>
<td/>
<td>
          If the 'backupFailurePolicy' is set to 'CUSTOM' then this attribute is
          required and should
          contain the fully qualified name of a class implementing
          org.infinispan.xsite.CustomFailurePolicy.
        </td>
</tr>
</table>
<div class="element">
<h3 class="heading">take-offline?</h3>
<div class="content">
<p>Determines whether this backup is taken offline (ignored) after a certain number of tries.</p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>after-failures</td>
<td>int</td>
<td>0</td>
<td>The number of failed request operations after which this site should be taken offline. Defaults to 0 (never). A negative value would mean that the site will be taken offline after 'min-wait'.</td>
</tr>
<tr>
<td>min-wait</td>
<td>long</td>
<td>0</td>
<td>The minimal number of millis to wait before taking this site offline, even in the case 'after-failures' is reached. If smaller or equal to 0, then only 'after-failures' is considered.</td>
</tr>
</table>
</div>
</div>
<div class="element">
<h3 class="heading">state-transfer?</h3>
<div class="content">
<p>
            Configures the properties needed to transfer the state for this site.
          </p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>chunk-size</td>
<td>int</td>
<td>512</td>
<td>
                If &gt; 0, the state will be transferred in batches of {@code chunkSize} cache entries.
                If &lt;= 0, the state will be transferred in all at once. Not recommended. Defaults to 512.
              </td>
</tr>
<tr>
<td>timeout</td>
<td>long</td>
<td>1200000</td>
<td>
                The time (in milliseconds) to wait for the backup site acknowledge the state chunk
                received and applied. Default value is 20 min.
              </td>
</tr>
<tr>
<td>max-retries</td>
<td>int</td>
<td>30</td>
<td>
                The maximum number of retries when a push state command fails. A value &lt;= 0 (zero) mean that
                the command will not retry. Default value is 30.
              </td>
</tr>
<tr>
<td>wait-time</td>
<td>long</td>
<td>2000</td>
<td>
                The waiting time (in milliseconds) between each retry. The value should be &gt; 0 (zero). Default
                value is 2 seconds.
              </td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="element">
<h3 class="heading">backup-for?</h3>
<div class="content">
<p>
            Configures this cache as a backup for a remote cache.
          </p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>remote-cache</td>
<td>string</td>
<td/>
<td>
                The name of the remote cache that backups data here.
              </td>
</tr>
<tr>
<td>remote-site</td>
<td>string</td>
<td/>
<td>
                The name of the remote site containing the cache that backups data here.
              </td>
</tr>
</table>
</div>
</div>
<div class="element">
<h3 class="heading">locking?</h3>
<div class="content">
<p>The locking configuration of the cache.</p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>isolation</td>
<td>
<table class="enumeration">
<tr>
<td title="No locking isolation will be performed. This is only valid in local mode. In clustered mode, READ_COMMITTED will be used instead.">NONE</td>
<td>No locking isolation will be performed. This is only valid in local mode. In clustered mode, READ_COMMITTED will be used instead.</td>
</tr>
<tr>
<td title="Unsupported. Actually configures READ_COMMITTED">READ_UNCOMMITTED</td>
<td>Unsupported. Actually configures READ_COMMITTED</td>
</tr>
<tr>
<td title="Read committed is an isolation level that guarantees that any data read is committed at the moment it is read. However, depending on the outcome of other transactions, successive reads may return different results">READ_COMMITTED</td>
<td>Read committed is an isolation level that guarantees that any data read is committed at the moment it is read. However, depending on the outcome of other transactions, successive reads may return different results</td>
</tr>
<tr>
<td title="Repeatable read is an isolation level that guarantees that any data read is committed at the moment it is read and that, within a transaction, successive reads will always return the same data.">REPEATABLE_READ</td>
<td>Repeatable read is an isolation level that guarantees that any data read is committed at the moment it is read and that, within a transaction, successive reads will always return the same data.</td>
</tr>
<tr>
<td title="Unsupported. Actually configures REPEATABLE_READ">SERIALIZABLE</td>
<td>Unsupported. Actually configures REPEATABLE_READ</td>
</tr>
</table>
</td>
<td>READ_COMMITTED</td>
<td>Sets the cache locking isolation level. Infinispan only supports READ_COMMITTED or REPEATABLE_READ isolation level.</td>
</tr>
<tr>
<td>striping</td>
<td>boolean</td>
<td>false</td>
<td>If true, a pool of shared locks is maintained for all entries that need to be locked. Otherwise, a lock is created per entry in the cache. Lock striping helps control memory footprint but may reduce concurrency in the system.</td>
</tr>
<tr>
<td>acquire-timeout</td>
<td>long</td>
<td>10000</td>
<td>Maximum time to attempt a particular lock acquisition.</td>
</tr>
<tr>
<td>concurrency-level</td>
<td>int</td>
<td>32</td>
<td>Concurrency level for lock containers. Adjust this value according to the number of concurrent threads interacting with Infinispan.</td>
</tr>
<tr>
<td>write-skew</td>
<td>boolean</td>
<td>false</td>
<td>
          This setting is only applicable in the case of REPEATABLE_READ. When write skew check is set to false, if the writer at commit time discovers that the working entry and the underlying entry have different versions, the working entry will overwrite the underlying entry. If true, such version conflict - known as a write-skew - will throw an Exception. Defaults to false.
        </td>
</tr>
</table>
</div>
</div>
<div class="element">
<h3 class="heading">transaction?</h3>
<div class="content">
<p>The cache transaction configuration.</p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>mode</td>
<td>
<table class="enumeration">
<tr>
<td title="Cache will not enlist within transactions.">NONE</td>
<td>Cache will not enlist within transactions.</td>
</tr>
<tr>
<td title="Uses batching to group cache operations together.">BATCH</td>
<td>Uses batching to group cache operations together.</td>
</tr>
<tr>
<td title="Cache will enlist within transactions as a javax.transaction.Synchronization">NON_XA</td>
<td>Cache will enlist within transactions as a javax.transaction.Synchronization</td>
</tr>
<tr>
<td title="Cache will enlist within transactions as a javax.transaction.xa.XAResource, without recovery.">NON_DURABLE_XA</td>
<td>Cache will enlist within transactions as a javax.transaction.xa.XAResource, without recovery.</td>
</tr>
<tr>
<td title="Cache will enlist within transactions as a javax.transaction.xa.XAResource, with recovery.">FULL_XA</td>
<td>Cache will enlist within transactions as a javax.transaction.xa.XAResource, with recovery.</td>
</tr>
</table>
</td>
<td>NONE</td>
<td>Sets the cache transaction mode to one of NONE, BATCH, NON_XA, NON_DURABLE_XA, FULL_XA.</td>
</tr>
<tr>
<td>stop-timeout</td>
<td>long</td>
<td>30000</td>
<td>If there are any ongoing transactions when a cache is stopped, Infinispan waits for ongoing remote and local transactions to finish. The amount of time to wait for is defined by the cache stop timeout.</td>
</tr>
<tr>
<td>locking</td>
<td>
<table class="enumeration">
<tr>
<td title="Enables Optimistic locking.">OPTIMISTIC</td>
<td>Enables Optimistic locking.</td>
</tr>
<tr>
<td title="Enables Pessimistic locking.">PESSIMISTIC</td>
<td>Enables Pessimistic locking.</td>
</tr>
</table>
</td>
<td>OPTIMISTIC</td>
<td>The locking mode for this cache, one of OPTIMISTIC or PESSIMISTIC.</td>
</tr>
<tr>
<td>transaction-manager-lookup</td>
<td>string</td>
<td>org.infinispan.transaction.lookup.GenericTransactionManagerLookup.GenericTransactionManagerLookup</td>
<td>
          Configure Transaction manager lookup directly using an instance of TransactionManagerLookup. Calling this method marks the cache as transactional.
        </td>
</tr>
<tr>
<td>complete-timeout</td>
<td>long</td>
<td>60000</td>
<td>
          The duration (millis) in which to keep information about the completion of a transaction. Defaults to 60000.
        </td>
</tr>
<tr>
<td>reaper-interval</td>
<td>long</td>
<td>30000</td>
<td>
          The time interval (millis) at which the thread that cleans up transaction completion information kicks in. Defaults to 30000.
        </td>
</tr>
<tr>
<td>auto-commit</td>
<td>boolean</td>
<td>true</td>
<td>
          If the cache is transactional and transactionAutoCommit is enabled then for single operation transactions the user doesn't need to manually start a transaction, but a transactions is injected by the system. Defaults to true.
        </td>
</tr>
<tr>
<td>protocol</td>
<td>
<table class="enumeration">
<tr>
<td title="">DEFAULT</td>
<td/>
</tr>
<tr>
<td title="">TOTAL_ORDER</td>
<td/>
</tr>
</table>
</td>
<td/>
<td>
          Configures the commit protocol to use.
        </td>
</tr>
<tr>
<td>recovery-cache</td>
<td>string</td>
<td>__recoveryInfoCacheName__</td>
<td>
          Sets the name of the cache where recovery related information is held. The cache's default name is "__recoveryInfoCacheName__"
        </td>
</tr>
<tr>
<td>notifications</td>
<td>boolean</td>
<td>true</td>
<td>
          Enables or disables triggering transactional notifications on cache listeners. By default is enabled.
        </td>
</tr>
</table>
</div>
</div>
<div class="element">
<h3 class="heading">eviction?</h3>
<div class="content">
<p>The cache eviction configuration.</p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>strategy</td>
<td>
<table class="enumeration">
<tr>
<td title="Never evict entries. This is the default.">NONE</td>
<td>Never evict entries. This is the default.</td>
</tr>
<tr>
<td title="Actually activates LRU.">UNORDERED</td>
<td>Actually activates LRU.</td>
</tr>
<tr>
<td title="Deprecated. Actually activates LRU.">FIFO</td>
<td>Deprecated. Actually activates LRU.</td>
</tr>
<tr>
<td title="Least-Recently Used policy.">LRU</td>
<td>Least-Recently Used policy.</td>
</tr>
<tr>
<td title="Low Inter-reference Recency Set. An improved version of LRU which uses cache-locality access information to better decide which data to evict.">LIRS</td>
<td>Low Inter-reference Recency Set. An improved version of LRU which uses cache-locality access information to better decide which data to evict.</td>
</tr>
<tr>
<td title="Eviction will be performed manually. Equivalent internally to NONE.">MANUAL</td>
<td>Eviction will be performed manually. Equivalent internally to NONE.</td>
</tr>
</table>
</td>
<td>NONE</td>
<td>Sets the cache eviction strategy. Available options are 'UNORDERED', 'FIFO', 'LRU', 'LIRS' and 'NONE' (to disable eviction).</td>
</tr>
<tr>
<td>max-entries</td>
<td>long</td>
<td>-1</td>
<td>Deprecated since 8.1. Use the size attribute instead.</td>
</tr>
<tr>
<td>thread-policy</td>
<td>
<table class="enumeration">
<tr>
<td title="Fires the eviction events from the same thread which is performing the eviction ">PIGGYBACK</td>
<td>Fires the eviction events from the same thread which is performing the eviction </td>
</tr>
<tr>
<td title="Use the default eviction listener thread policy (PIGGYBACK)">DEFAULT</td>
<td>Use the default eviction listener thread policy (PIGGYBACK)</td>
</tr>
</table>
</td>
<td>DEFAULT</td>
<td>
          Threading policy for eviction. Defaults to using the DEFAULT eviction policy.
        </td>
</tr>
<tr>
<td>type</td>
<td>
<table class="enumeration">
<tr>
<td title="Evicts entries from the cache when a specified count has been set">COUNT</td>
<td>Evicts entries from the cache when a specified count has been set</td>
</tr>
<tr>
<td title="Evicts entries from the cache when a specified memory usage has been reached. Memory usage is computed using an approximation which is tailored for the HotSpot VM. This can only be used when both key and values are stored as byte arrays. To guarantee only byte arrays are stored it is recommended to run with store as binary for both keys and values">MEMORY</td>
<td>Evicts entries from the cache when a specified memory usage has been reached. Memory usage is computed using an approximation which is tailored for the HotSpot VM. This can only be used when both key and values are stored as byte arrays. To guarantee only byte arrays are stored it is recommended to run with store as binary for both keys and values</td>
</tr>
</table>
</td>
<td>COUNT</td>
<td>Specifies whether to use entry count or memory-based approximation to decide when to evict entries.</td>
</tr>
<tr>
<td>size</td>
<td>long</td>
<td>-1</td>
<td>Maximum size to use for eviction. When using the COUNT type, this is the maximum number of entries in a cache instance. When using the MEMORY threshold policy, this is the maximum number of allocated bytes used by a cache's datacontainer. A value of -1 means no limit. This is currently limited to 2^48 - 1 in size.</td>
</tr>
</table>
</div>
</div>
<div class="element">
<h3 class="heading">expiration?</h3>
<div class="content">
<p>The cache expiration configuration.</p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>max-idle</td>
<td>long</td>
<td>-1</td>
<td>Maximum idle time a cache entry will be maintained in the cache, in milliseconds. If the idle time is exceeded, the entry will be expired cluster-wide. -1 means the entries never expire.</td>
</tr>
<tr>
<td>lifespan</td>
<td>long</td>
<td>-1</td>
<td>Maximum lifespan of a cache entry, after which the entry is expired cluster-wide, in milliseconds. -1 means the entries never expire.</td>
</tr>
<tr>
<td>interval</td>
<td>long</td>
<td>60000</td>
<td>Interval (in milliseconds) between subsequent runs to purge expired entries from memory and any cache stores. If you wish to disable the periodic eviction process altogether, set interval to -1.</td>
</tr>
</table>
</div>
</div>
<div class="element">
<h3 class="heading">compatibility?</h3>
<div class="content">
<p>The cache compatibility mode configuration.</p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>marshaller</td>
<td>string</td>
<td/>
<td>A marshaller to use for compatibility conversions.</td>
</tr>
</table>
</div>
</div>
<div class="element">
<h3 class="heading">store-as-binary?</h3>
<div class="content">
<p>Configures the cache to store data in binary format.</p>
        Controls whether when stored in memory, keys and values are stored as references to their original objects, or in a serialized, binary format.  There are benefits to both approaches, but often if used in a clustered mode, storing objects as binary means that the cost of serialization happens early on, and can be amortized.  Further, deserialization costs are incurred lazily which improves throughput. It is possible to control this on a fine-grained basis: you can choose to just store keys or values as binary, or both.
      <table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>keys</td>
<td>boolean</td>
<td>true</td>
<td>
          Specify whether keys are stored as binary or not. Enabled by default if the "enabled" attribute is set to true.
        </td>
</tr>
<tr>
<td>values</td>
<td>boolean</td>
<td>true</td>
<td>
          Specify whether values are stored as binary or not. Enabled by default if the "enabled" attribute is set to true.
        </td>
</tr>
</table>
</div>
</div>
<div class="element">
<h3 class="heading">persistence?</h3>
<div class="content">
<p>Configures the cache's persistence layer.</p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>passivation</td>
<td>boolean</td>
<td>false</td>
<td>
          If true, data is only written to the cache store when it is evicted from memory, a phenomenon known as 'passivation'. Next time the data is requested, it will be 'activated' which means that data will be brought back to memory and removed from the persistent store. This gives you the ability to 'overflow' to disk, similar to swapping in an operating system. If false, the cache store contains a copy of the contents in memory, so writes to cache result in cache store writes. This essentially gives you a 'write-through' configuration. Defaults to false.
        </td>
</tr>
</table>
</div>
</div>
<div class="element">
<h3 class="heading">versioning?</h3>
<div class="content">
<p>
            Controls whether entries are versioned.  Versioning is necessary, for example, when using optimistic transactions in a clustered environment, to be able to perform write-skew checks.
          </p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>scheme</td>
<td>
<table class="enumeration">
<tr>
<td title="&#10;            A simple versioning scheme that is cluster-aware&#10;          ">SIMPLE</td>
<td>
            A simple versioning scheme that is cluster-aware
          </td>
</tr>
<tr>
<td title="&#10;            Don't version entries&#10;          ">NONE</td>
<td>
            Don't version entries
          </td>
</tr>
</table>
</td>
<td>NONE</td>
<td>
          The scheme to use when versioning entries. Can be either SIMPLE or NONE. Defaults to NONE
        </td>
</tr>
</table>
</div>
</div>
<div class="element">
<h3 class="heading">data-container?</h3>
<div class="content">
<p>
            Controls the data container for the cache.
          </p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>class</td>
<td>string</td>
<td/>
<td>
          DEPRECATED: this is to be removed in a future release
          Fully qualified class name of the data container to use
        </td>
</tr>
<tr>
<td>key-equivalence</td>
<td>string</td>
<td/>
<td>
          Fully qualified class name of the Equivalence class to use
          for keys stored in the cache, which provides with custom
          ways to compare cached keys
        </td>
</tr>
<tr>
<td>value-equivalence</td>
<td>string</td>
<td/>
<td>
          Fully qualified class name of the Equivalence class to use
          for values stored in the cache, which provides with custom
          ways to compare cached values
        </td>
</tr>
</table>
<div class="element">
<h3 class="heading">property*</h3>
<div class="content">
<p>Properties passed to the data container</p>
</div>
</div>
</div>
</div>
<div class="element">
<h3 class="heading">modules?</h3>
<div class="content">
<p>
            This element contains configuration options for additional modules which affect cache configuration
          </p>
</div>
</div>
<div class="element">
<h3 class="heading">indexing?</h3>
<div class="content">
<p>
            Defines indexing options for cache
          </p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>index</td>
<td>
<table class="enumeration">
<tr>
<td title="Do not index data. This is the default.">NONE</td>
<td>Do not index data. This is the default.</td>
</tr>
<tr>
<td title="Only index changes made locally, ignoring remote changes. This is useful if indexes are shared across a cluster to prevent redundant indexing of updates.">LOCAL</td>
<td>Only index changes made locally, ignoring remote changes. This is useful if indexes are shared across a cluster to prevent redundant indexing of updates.</td>
</tr>
<tr>
<td title="Index all data">ALL</td>
<td>Index all data</td>
</tr>
</table>
</td>
<td>NONE</td>
<td>The indexing mode of the cache. Defaults to NONE.</td>
</tr>
<tr>
<td>auto-config</td>
<td>boolean</td>
<td>false</td>
<td>Whether or not to apply automatic index configuration based on cache type</td>
</tr>
</table>
<div class="element">
<h3 class="heading">indexed-entities?</h3>
<div class="content">
<p>Defines the indexed entity classes</p>
<div class="element">
<h3 class="heading">indexed-entity*</h3>
<div class="content">
<p>Indexed entity class name</p>
</div>
</div>
</div>
</div>
<div class="element">
<h3 class="heading">property*</h3>
<div class="content">
<p>Property to pass on to the indexing system</p>
</div>
</div>
</div>
</div>
<div class="element">
<h3 class="heading">custom-interceptors?</h3>
<div class="content">
<p>Configures custom interceptors to be added to the cache.</p>
<div class="element">
<h3 class="heading">interceptor*</h3>
<div class="content">
<p/>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>after</td>
<td>string</td>
<td/>
<td>Dictates that the custom interceptor appears immediately after the specified interceptor. If the specified interceptor is not found in the interceptor chain, a ConfigurationException will be thrown when the cache starts.</td>
</tr>
<tr>
<td>before</td>
<td>string</td>
<td/>
<td>Dictates that the custom interceptor appears immediately before the specified interceptor. If the specified interceptor is not found in the interceptor chain, a ConfigurationException will be thrown when the cache starts.</td>
</tr>
<tr>
<td>class</td>
<td>string</td>
<td/>
<td>A fully qualified class name of the new custom interceptor to add to the configuration.</td>
</tr>
<tr>
<td>index</td>
<td>int</td>
<td/>
<td>Specifies a position in the interceptor chain to place the new interceptor. The index starts at 0 and goes up to the number of interceptors in a given configuration. A ConfigurationException is thrown if the index is less than 0 or greater than the maximum number of interceptors in the chain.</td>
</tr>
<tr>
<td>position</td>
<td>string</td>
<td/>
<td>Specifies a position where to place the new interceptor. Allowed values are FIRST, LAST, and OTHER_THAN_FIRST_OR_LAST</td>
</tr>
</table>
<div class="element">
<h3 class="heading">property?</h3>
<div class="content">
<p/>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="element">
<h3 class="heading">security?</h3>
<div class="content">
<p>Configures cache-level security.</p>
<div class="element">
<h3 class="heading">authorization?</h3>
<div class="content">
<p>
            Configures authorization for this cache.
          </p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>enabled</td>
<td>boolean</td>
<td>true</td>
<td>
                Enables authorization checks for this cache. Defaults to true if the authorization element is present.
              </td>
</tr>
<tr>
<td>roles</td>
<td/>
<td/>
<td>
                Sets the valid roles required to access this cache.
              </td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
        <div class="element">
<h3 class="heading">invalidation-cache</h3>
<div class="content">
<p>Defines an INVALIDATION_* mode cache.</p>
<div>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>mode</td>
<td>
<table class="enumeration">
<tr>
<td title="Enables asynchronous mode.">ASYNC</td>
<td>Enables asynchronous mode.</td>
</tr>
<tr>
<td title="Enables synchronous mode.">SYNC</td>
<td>Enables synchronous mode.</td>
</tr>
</table>
</td>
<td/>
<td>Sets the clustered cache mode, ASYNC for asynchronous operation, or SYNC for synchronous operation.</td>
</tr>
<tr>
<td>queue-size</td>
<td>int</td>
<td>0</td>
<td>Deprecated. In ASYNC mode, this attribute can be used to trigger flushing of the queue when it reaches a specific threshold. A value of 0 (the default) disables the replication queue.</td>
</tr>
<tr>
<td>queue-flush-interval</td>
<td>long</td>
<td>10</td>
<td>Deprecated. In ASYNC mode, this attribute controls how often the asynchronous thread used to flush the replication queue runs. This should be a positive integer which represents thread wakeup time in milliseconds.</td>
</tr>
<tr>
<td>remote-timeout</td>
<td>long</td>
<td>15000</td>
<td>In SYNC mode, the timeout (in ms) used to wait for an acknowledgment when making a remote call, after which the call is aborted and an exception is thrown.</td>
</tr>
</table>
<div class="element">
<h3 class="heading">partition-handling?</h3>
<div class="content">
<p>
                   Configures the way this cache reacts to node crashes and split brains.
                </p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>enabled</td>
<td>boolean</td>
<td/>
<td>
                         Enable/disable the partition handling functionality. Defaults to false.
                      </td>
</tr>
</table>
</div>
</div>
<div>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>name</td>
<td>ID</td>
<td/>
<td>Uniquely identifies this cache within its cache container.</td>
</tr>
<tr>
<td>configuration</td>
<td>IDREF</td>
<td/>
<td>The name of the cache configuration which this configuration inherits from.</td>
</tr>
<tr>
<td>start</td>
<td>
<span class="error">FIXME</span>
</td>
<td/>
<td>Unused XML attribute</td>
</tr>
<tr>
<td>jndi-name</td>
<td>string</td>
<td/>
<td>Unused XML attribute</td>
</tr>
<tr>
<td>module</td>
<td>string</td>
<td/>
<td>Unused XML attribute</td>
</tr>
<tr>
<td>statistics</td>
<td>boolean</td>
<td>true</td>
<td>Determines whether or not the cache should collect statistics.  Keep disabled for optimal performance.</td>
</tr>
<tr>
<td>statistics-available</td>
<td>boolean</td>
<td>true</td>
<td>If set to false, statistics gathering cannot be enabled during runtime. Keep disabled for optimal performance.</td>
</tr>
<tr>
<td>deadlock-detection-spin</td>
<td>long</td>
<td>100</td>
<td>
          Time period that determines how often is lock acquisition attempted within maximum time allowed to acquire a particular lock. Defaults to 100ms.
        </td>
</tr>
<tr>
<td>unreliable-return-values</td>
<td>boolean</td>
<td>false</td>
<td>
          Specifies whether Infinispan is allowed to disregard the Map contract when providing return values for org.infinispan.Cache#put(Object, Object) and org.infinispan.Cache#remove(Object) methods.
        </td>
</tr>
</table>
<div class="element">
<h3 class="heading">backups?</h3>
<div class="content">
<p>The state transfer configuration for distribution and replicated caches.</p>
<div class="element">
<h3 class="heading">backup*</h3>
<div class="content">
<p>Configures a specific site where this cache backups data.</p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>site</td>
<td>string</td>
<td/>
<td>Name of the remote site where this cache backups data.</td>
</tr>
<tr>
<td>strategy</td>
<td>
<table class="enumeration">
<tr>
<td title="Enables asynchronous mode.">ASYNC</td>
<td>Enables asynchronous mode.</td>
</tr>
<tr>
<td title="Enables synchronous mode.">SYNC</td>
<td>Enables synchronous mode.</td>
</tr>
</table>
</td>
<td>ASYNC</td>
<td>The strategy used for backing up data: "SYNC" or "ASYNC". Defaults to "ASYNC"</td>
</tr>
<tr>
<td>failure-policy</td>
<td>
<table class="enumeration">
<tr>
<td title="Ignore backup failures.">IGNORE</td>
<td>Ignore backup failures.</td>
</tr>
<tr>
<td title="Warn of backup failures.">WARN</td>
<td>Warn of backup failures.</td>
</tr>
<tr>
<td title="Fail local operations when a backup failure occurs.">FAIL</td>
<td>Fail local operations when a backup failure occurs.</td>
</tr>
<tr>
<td title="Invoke a user-specified failure policy (set via the failure-policy-class attribute)">CUSTOM</td>
<td>Invoke a user-specified failure policy (set via the failure-policy-class attribute)</td>
</tr>
</table>
</td>
<td>WARN</td>
<td>Decides what the system would do in case of failure during backup. Defaults to "WARN"</td>
</tr>
<tr>
<td>timeout</td>
<td>long</td>
<td>10000</td>
<td>The timeout(millis) to be used when backing up data remotely. Defaults to 10 secs.</td>
</tr>
<tr>
<td>enabled</td>
<td>boolean</td>
<td>true</td>
<td>If 'false' then no data is backed up to this site. Defaults to 'true'.</td>
</tr>
<tr>
<td>two-phase-commit</td>
<td>boolean</td>
<td>false</td>
<td>
          Configures whether the replication happens in a 1PC or 2PC when using SYNC backup strategy. Defaults to "false".
          CacheConfigurationException is thrown when used with ASYNC backup strategy.
        </td>
</tr>
<tr>
<td>failure-policy-class</td>
<td>string</td>
<td/>
<td>
          If the 'backupFailurePolicy' is set to 'CUSTOM' then this attribute is
          required and should
          contain the fully qualified name of a class implementing
          org.infinispan.xsite.CustomFailurePolicy.
        </td>
</tr>
</table>
<div class="element">
<h3 class="heading">take-offline?</h3>
<div class="content">
<p>Determines whether this backup is taken offline (ignored) after a certain number of tries.</p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>after-failures</td>
<td>int</td>
<td>0</td>
<td>The number of failed request operations after which this site should be taken offline. Defaults to 0 (never). A negative value would mean that the site will be taken offline after 'min-wait'.</td>
</tr>
<tr>
<td>min-wait</td>
<td>long</td>
<td>0</td>
<td>The minimal number of millis to wait before taking this site offline, even in the case 'after-failures' is reached. If smaller or equal to 0, then only 'after-failures' is considered.</td>
</tr>
</table>
</div>
</div>
<div class="element">
<h3 class="heading">state-transfer?</h3>
<div class="content">
<p>
            Configures the properties needed to transfer the state for this site.
          </p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>chunk-size</td>
<td>int</td>
<td>512</td>
<td>
                If &gt; 0, the state will be transferred in batches of {@code chunkSize} cache entries.
                If &lt;= 0, the state will be transferred in all at once. Not recommended. Defaults to 512.
              </td>
</tr>
<tr>
<td>timeout</td>
<td>long</td>
<td>1200000</td>
<td>
                The time (in milliseconds) to wait for the backup site acknowledge the state chunk
                received and applied. Default value is 20 min.
              </td>
</tr>
<tr>
<td>max-retries</td>
<td>int</td>
<td>30</td>
<td>
                The maximum number of retries when a push state command fails. A value &lt;= 0 (zero) mean that
                the command will not retry. Default value is 30.
              </td>
</tr>
<tr>
<td>wait-time</td>
<td>long</td>
<td>2000</td>
<td>
                The waiting time (in milliseconds) between each retry. The value should be &gt; 0 (zero). Default
                value is 2 seconds.
              </td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="element">
<h3 class="heading">backup-for?</h3>
<div class="content">
<p>
            Configures this cache as a backup for a remote cache.
          </p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>remote-cache</td>
<td>string</td>
<td/>
<td>
                The name of the remote cache that backups data here.
              </td>
</tr>
<tr>
<td>remote-site</td>
<td>string</td>
<td/>
<td>
                The name of the remote site containing the cache that backups data here.
              </td>
</tr>
</table>
</div>
</div>
<div class="element">
<h3 class="heading">locking?</h3>
<div class="content">
<p>The locking configuration of the cache.</p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>isolation</td>
<td>
<table class="enumeration">
<tr>
<td title="No locking isolation will be performed. This is only valid in local mode. In clustered mode, READ_COMMITTED will be used instead.">NONE</td>
<td>No locking isolation will be performed. This is only valid in local mode. In clustered mode, READ_COMMITTED will be used instead.</td>
</tr>
<tr>
<td title="Unsupported. Actually configures READ_COMMITTED">READ_UNCOMMITTED</td>
<td>Unsupported. Actually configures READ_COMMITTED</td>
</tr>
<tr>
<td title="Read committed is an isolation level that guarantees that any data read is committed at the moment it is read. However, depending on the outcome of other transactions, successive reads may return different results">READ_COMMITTED</td>
<td>Read committed is an isolation level that guarantees that any data read is committed at the moment it is read. However, depending on the outcome of other transactions, successive reads may return different results</td>
</tr>
<tr>
<td title="Repeatable read is an isolation level that guarantees that any data read is committed at the moment it is read and that, within a transaction, successive reads will always return the same data.">REPEATABLE_READ</td>
<td>Repeatable read is an isolation level that guarantees that any data read is committed at the moment it is read and that, within a transaction, successive reads will always return the same data.</td>
</tr>
<tr>
<td title="Unsupported. Actually configures REPEATABLE_READ">SERIALIZABLE</td>
<td>Unsupported. Actually configures REPEATABLE_READ</td>
</tr>
</table>
</td>
<td>READ_COMMITTED</td>
<td>Sets the cache locking isolation level. Infinispan only supports READ_COMMITTED or REPEATABLE_READ isolation level.</td>
</tr>
<tr>
<td>striping</td>
<td>boolean</td>
<td>false</td>
<td>If true, a pool of shared locks is maintained for all entries that need to be locked. Otherwise, a lock is created per entry in the cache. Lock striping helps control memory footprint but may reduce concurrency in the system.</td>
</tr>
<tr>
<td>acquire-timeout</td>
<td>long</td>
<td>10000</td>
<td>Maximum time to attempt a particular lock acquisition.</td>
</tr>
<tr>
<td>concurrency-level</td>
<td>int</td>
<td>32</td>
<td>Concurrency level for lock containers. Adjust this value according to the number of concurrent threads interacting with Infinispan.</td>
</tr>
<tr>
<td>write-skew</td>
<td>boolean</td>
<td>false</td>
<td>
          This setting is only applicable in the case of REPEATABLE_READ. When write skew check is set to false, if the writer at commit time discovers that the working entry and the underlying entry have different versions, the working entry will overwrite the underlying entry. If true, such version conflict - known as a write-skew - will throw an Exception. Defaults to false.
        </td>
</tr>
</table>
</div>
</div>
<div class="element">
<h3 class="heading">transaction?</h3>
<div class="content">
<p>The cache transaction configuration.</p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>mode</td>
<td>
<table class="enumeration">
<tr>
<td title="Cache will not enlist within transactions.">NONE</td>
<td>Cache will not enlist within transactions.</td>
</tr>
<tr>
<td title="Uses batching to group cache operations together.">BATCH</td>
<td>Uses batching to group cache operations together.</td>
</tr>
<tr>
<td title="Cache will enlist within transactions as a javax.transaction.Synchronization">NON_XA</td>
<td>Cache will enlist within transactions as a javax.transaction.Synchronization</td>
</tr>
<tr>
<td title="Cache will enlist within transactions as a javax.transaction.xa.XAResource, without recovery.">NON_DURABLE_XA</td>
<td>Cache will enlist within transactions as a javax.transaction.xa.XAResource, without recovery.</td>
</tr>
<tr>
<td title="Cache will enlist within transactions as a javax.transaction.xa.XAResource, with recovery.">FULL_XA</td>
<td>Cache will enlist within transactions as a javax.transaction.xa.XAResource, with recovery.</td>
</tr>
</table>
</td>
<td>NONE</td>
<td>Sets the cache transaction mode to one of NONE, BATCH, NON_XA, NON_DURABLE_XA, FULL_XA.</td>
</tr>
<tr>
<td>stop-timeout</td>
<td>long</td>
<td>30000</td>
<td>If there are any ongoing transactions when a cache is stopped, Infinispan waits for ongoing remote and local transactions to finish. The amount of time to wait for is defined by the cache stop timeout.</td>
</tr>
<tr>
<td>locking</td>
<td>
<table class="enumeration">
<tr>
<td title="Enables Optimistic locking.">OPTIMISTIC</td>
<td>Enables Optimistic locking.</td>
</tr>
<tr>
<td title="Enables Pessimistic locking.">PESSIMISTIC</td>
<td>Enables Pessimistic locking.</td>
</tr>
</table>
</td>
<td>OPTIMISTIC</td>
<td>The locking mode for this cache, one of OPTIMISTIC or PESSIMISTIC.</td>
</tr>
<tr>
<td>transaction-manager-lookup</td>
<td>string</td>
<td>org.infinispan.transaction.lookup.GenericTransactionManagerLookup.GenericTransactionManagerLookup</td>
<td>
          Configure Transaction manager lookup directly using an instance of TransactionManagerLookup. Calling this method marks the cache as transactional.
        </td>
</tr>
<tr>
<td>complete-timeout</td>
<td>long</td>
<td>60000</td>
<td>
          The duration (millis) in which to keep information about the completion of a transaction. Defaults to 60000.
        </td>
</tr>
<tr>
<td>reaper-interval</td>
<td>long</td>
<td>30000</td>
<td>
          The time interval (millis) at which the thread that cleans up transaction completion information kicks in. Defaults to 30000.
        </td>
</tr>
<tr>
<td>auto-commit</td>
<td>boolean</td>
<td>true</td>
<td>
          If the cache is transactional and transactionAutoCommit is enabled then for single operation transactions the user doesn't need to manually start a transaction, but a transactions is injected by the system. Defaults to true.
        </td>
</tr>
<tr>
<td>protocol</td>
<td>
<table class="enumeration">
<tr>
<td title="">DEFAULT</td>
<td/>
</tr>
<tr>
<td title="">TOTAL_ORDER</td>
<td/>
</tr>
</table>
</td>
<td/>
<td>
          Configures the commit protocol to use.
        </td>
</tr>
<tr>
<td>recovery-cache</td>
<td>string</td>
<td>__recoveryInfoCacheName__</td>
<td>
          Sets the name of the cache where recovery related information is held. The cache's default name is "__recoveryInfoCacheName__"
        </td>
</tr>
<tr>
<td>notifications</td>
<td>boolean</td>
<td>true</td>
<td>
          Enables or disables triggering transactional notifications on cache listeners. By default is enabled.
        </td>
</tr>
</table>
</div>
</div>
<div class="element">
<h3 class="heading">eviction?</h3>
<div class="content">
<p>The cache eviction configuration.</p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>strategy</td>
<td>
<table class="enumeration">
<tr>
<td title="Never evict entries. This is the default.">NONE</td>
<td>Never evict entries. This is the default.</td>
</tr>
<tr>
<td title="Actually activates LRU.">UNORDERED</td>
<td>Actually activates LRU.</td>
</tr>
<tr>
<td title="Deprecated. Actually activates LRU.">FIFO</td>
<td>Deprecated. Actually activates LRU.</td>
</tr>
<tr>
<td title="Least-Recently Used policy.">LRU</td>
<td>Least-Recently Used policy.</td>
</tr>
<tr>
<td title="Low Inter-reference Recency Set. An improved version of LRU which uses cache-locality access information to better decide which data to evict.">LIRS</td>
<td>Low Inter-reference Recency Set. An improved version of LRU which uses cache-locality access information to better decide which data to evict.</td>
</tr>
<tr>
<td title="Eviction will be performed manually. Equivalent internally to NONE.">MANUAL</td>
<td>Eviction will be performed manually. Equivalent internally to NONE.</td>
</tr>
</table>
</td>
<td>NONE</td>
<td>Sets the cache eviction strategy. Available options are 'UNORDERED', 'FIFO', 'LRU', 'LIRS' and 'NONE' (to disable eviction).</td>
</tr>
<tr>
<td>max-entries</td>
<td>long</td>
<td>-1</td>
<td>Deprecated since 8.1. Use the size attribute instead.</td>
</tr>
<tr>
<td>thread-policy</td>
<td>
<table class="enumeration">
<tr>
<td title="Fires the eviction events from the same thread which is performing the eviction ">PIGGYBACK</td>
<td>Fires the eviction events from the same thread which is performing the eviction </td>
</tr>
<tr>
<td title="Use the default eviction listener thread policy (PIGGYBACK)">DEFAULT</td>
<td>Use the default eviction listener thread policy (PIGGYBACK)</td>
</tr>
</table>
</td>
<td>DEFAULT</td>
<td>
          Threading policy for eviction. Defaults to using the DEFAULT eviction policy.
        </td>
</tr>
<tr>
<td>type</td>
<td>
<table class="enumeration">
<tr>
<td title="Evicts entries from the cache when a specified count has been set">COUNT</td>
<td>Evicts entries from the cache when a specified count has been set</td>
</tr>
<tr>
<td title="Evicts entries from the cache when a specified memory usage has been reached. Memory usage is computed using an approximation which is tailored for the HotSpot VM. This can only be used when both key and values are stored as byte arrays. To guarantee only byte arrays are stored it is recommended to run with store as binary for both keys and values">MEMORY</td>
<td>Evicts entries from the cache when a specified memory usage has been reached. Memory usage is computed using an approximation which is tailored for the HotSpot VM. This can only be used when both key and values are stored as byte arrays. To guarantee only byte arrays are stored it is recommended to run with store as binary for both keys and values</td>
</tr>
</table>
</td>
<td>COUNT</td>
<td>Specifies whether to use entry count or memory-based approximation to decide when to evict entries.</td>
</tr>
<tr>
<td>size</td>
<td>long</td>
<td>-1</td>
<td>Maximum size to use for eviction. When using the COUNT type, this is the maximum number of entries in a cache instance. When using the MEMORY threshold policy, this is the maximum number of allocated bytes used by a cache's datacontainer. A value of -1 means no limit. This is currently limited to 2^48 - 1 in size.</td>
</tr>
</table>
</div>
</div>
<div class="element">
<h3 class="heading">expiration?</h3>
<div class="content">
<p>The cache expiration configuration.</p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>max-idle</td>
<td>long</td>
<td>-1</td>
<td>Maximum idle time a cache entry will be maintained in the cache, in milliseconds. If the idle time is exceeded, the entry will be expired cluster-wide. -1 means the entries never expire.</td>
</tr>
<tr>
<td>lifespan</td>
<td>long</td>
<td>-1</td>
<td>Maximum lifespan of a cache entry, after which the entry is expired cluster-wide, in milliseconds. -1 means the entries never expire.</td>
</tr>
<tr>
<td>interval</td>
<td>long</td>
<td>60000</td>
<td>Interval (in milliseconds) between subsequent runs to purge expired entries from memory and any cache stores. If you wish to disable the periodic eviction process altogether, set interval to -1.</td>
</tr>
</table>
</div>
</div>
<div class="element">
<h3 class="heading">compatibility?</h3>
<div class="content">
<p>The cache compatibility mode configuration.</p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>marshaller</td>
<td>string</td>
<td/>
<td>A marshaller to use for compatibility conversions.</td>
</tr>
</table>
</div>
</div>
<div class="element">
<h3 class="heading">store-as-binary?</h3>
<div class="content">
<p>Configures the cache to store data in binary format.</p>
        Controls whether when stored in memory, keys and values are stored as references to their original objects, or in a serialized, binary format.  There are benefits to both approaches, but often if used in a clustered mode, storing objects as binary means that the cost of serialization happens early on, and can be amortized.  Further, deserialization costs are incurred lazily which improves throughput. It is possible to control this on a fine-grained basis: you can choose to just store keys or values as binary, or both.
      <table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>keys</td>
<td>boolean</td>
<td>true</td>
<td>
          Specify whether keys are stored as binary or not. Enabled by default if the "enabled" attribute is set to true.
        </td>
</tr>
<tr>
<td>values</td>
<td>boolean</td>
<td>true</td>
<td>
          Specify whether values are stored as binary or not. Enabled by default if the "enabled" attribute is set to true.
        </td>
</tr>
</table>
</div>
</div>
<div class="element">
<h3 class="heading">persistence?</h3>
<div class="content">
<p>Configures the cache's persistence layer.</p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>passivation</td>
<td>boolean</td>
<td>false</td>
<td>
          If true, data is only written to the cache store when it is evicted from memory, a phenomenon known as 'passivation'. Next time the data is requested, it will be 'activated' which means that data will be brought back to memory and removed from the persistent store. This gives you the ability to 'overflow' to disk, similar to swapping in an operating system. If false, the cache store contains a copy of the contents in memory, so writes to cache result in cache store writes. This essentially gives you a 'write-through' configuration. Defaults to false.
        </td>
</tr>
</table>
</div>
</div>
<div class="element">
<h3 class="heading">versioning?</h3>
<div class="content">
<p>
            Controls whether entries are versioned.  Versioning is necessary, for example, when using optimistic transactions in a clustered environment, to be able to perform write-skew checks.
          </p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>scheme</td>
<td>
<table class="enumeration">
<tr>
<td title="&#10;            A simple versioning scheme that is cluster-aware&#10;          ">SIMPLE</td>
<td>
            A simple versioning scheme that is cluster-aware
          </td>
</tr>
<tr>
<td title="&#10;            Don't version entries&#10;          ">NONE</td>
<td>
            Don't version entries
          </td>
</tr>
</table>
</td>
<td>NONE</td>
<td>
          The scheme to use when versioning entries. Can be either SIMPLE or NONE. Defaults to NONE
        </td>
</tr>
</table>
</div>
</div>
<div class="element">
<h3 class="heading">data-container?</h3>
<div class="content">
<p>
            Controls the data container for the cache.
          </p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>class</td>
<td>string</td>
<td/>
<td>
          DEPRECATED: this is to be removed in a future release
          Fully qualified class name of the data container to use
        </td>
</tr>
<tr>
<td>key-equivalence</td>
<td>string</td>
<td/>
<td>
          Fully qualified class name of the Equivalence class to use
          for keys stored in the cache, which provides with custom
          ways to compare cached keys
        </td>
</tr>
<tr>
<td>value-equivalence</td>
<td>string</td>
<td/>
<td>
          Fully qualified class name of the Equivalence class to use
          for values stored in the cache, which provides with custom
          ways to compare cached values
        </td>
</tr>
</table>
<div class="element">
<h3 class="heading">property*</h3>
<div class="content">
<p>Properties passed to the data container</p>
</div>
</div>
</div>
</div>
<div class="element">
<h3 class="heading">modules?</h3>
<div class="content">
<p>
            This element contains configuration options for additional modules which affect cache configuration
          </p>
</div>
</div>
<div class="element">
<h3 class="heading">indexing?</h3>
<div class="content">
<p>
            Defines indexing options for cache
          </p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>index</td>
<td>
<table class="enumeration">
<tr>
<td title="Do not index data. This is the default.">NONE</td>
<td>Do not index data. This is the default.</td>
</tr>
<tr>
<td title="Only index changes made locally, ignoring remote changes. This is useful if indexes are shared across a cluster to prevent redundant indexing of updates.">LOCAL</td>
<td>Only index changes made locally, ignoring remote changes. This is useful if indexes are shared across a cluster to prevent redundant indexing of updates.</td>
</tr>
<tr>
<td title="Index all data">ALL</td>
<td>Index all data</td>
</tr>
</table>
</td>
<td>NONE</td>
<td>The indexing mode of the cache. Defaults to NONE.</td>
</tr>
<tr>
<td>auto-config</td>
<td>boolean</td>
<td>false</td>
<td>Whether or not to apply automatic index configuration based on cache type</td>
</tr>
</table>
<div class="element">
<h3 class="heading">indexed-entities?</h3>
<div class="content">
<p>Defines the indexed entity classes</p>
<div class="element">
<h3 class="heading">indexed-entity*</h3>
<div class="content">
<p>Indexed entity class name</p>
</div>
</div>
</div>
</div>
<div class="element">
<h3 class="heading">property*</h3>
<div class="content">
<p>Property to pass on to the indexing system</p>
</div>
</div>
</div>
</div>
<div class="element">
<h3 class="heading">custom-interceptors?</h3>
<div class="content">
<p>Configures custom interceptors to be added to the cache.</p>
<div class="element">
<h3 class="heading">interceptor*</h3>
<div class="content">
<p/>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>after</td>
<td>string</td>
<td/>
<td>Dictates that the custom interceptor appears immediately after the specified interceptor. If the specified interceptor is not found in the interceptor chain, a ConfigurationException will be thrown when the cache starts.</td>
</tr>
<tr>
<td>before</td>
<td>string</td>
<td/>
<td>Dictates that the custom interceptor appears immediately before the specified interceptor. If the specified interceptor is not found in the interceptor chain, a ConfigurationException will be thrown when the cache starts.</td>
</tr>
<tr>
<td>class</td>
<td>string</td>
<td/>
<td>A fully qualified class name of the new custom interceptor to add to the configuration.</td>
</tr>
<tr>
<td>index</td>
<td>int</td>
<td/>
<td>Specifies a position in the interceptor chain to place the new interceptor. The index starts at 0 and goes up to the number of interceptors in a given configuration. A ConfigurationException is thrown if the index is less than 0 or greater than the maximum number of interceptors in the chain.</td>
</tr>
<tr>
<td>position</td>
<td>string</td>
<td/>
<td>Specifies a position where to place the new interceptor. Allowed values are FIRST, LAST, and OTHER_THAN_FIRST_OR_LAST</td>
</tr>
</table>
<div class="element">
<h3 class="heading">property?</h3>
<div class="content">
<p/>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="element">
<h3 class="heading">security?</h3>
<div class="content">
<p>Configures cache-level security.</p>
<div class="element">
<h3 class="heading">authorization?</h3>
<div class="content">
<p>
            Configures authorization for this cache.
          </p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>enabled</td>
<td>boolean</td>
<td>true</td>
<td>
                Enables authorization checks for this cache. Defaults to true if the authorization element is present.
              </td>
</tr>
<tr>
<td>roles</td>
<td/>
<td/>
<td>
                Sets the valid roles required to access this cache.
              </td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
        <div class="element">
<h3 class="heading">invalidation-cache-configuration</h3>
<div class="content">
<p>Defines an INVALIDATION_* mode cache configuration.</p>
<div>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>mode</td>
<td>
<table class="enumeration">
<tr>
<td title="Enables asynchronous mode.">ASYNC</td>
<td>Enables asynchronous mode.</td>
</tr>
<tr>
<td title="Enables synchronous mode.">SYNC</td>
<td>Enables synchronous mode.</td>
</tr>
</table>
</td>
<td/>
<td>Sets the clustered cache mode, ASYNC for asynchronous operation, or SYNC for synchronous operation.</td>
</tr>
<tr>
<td>queue-size</td>
<td>int</td>
<td>0</td>
<td>Deprecated. In ASYNC mode, this attribute can be used to trigger flushing of the queue when it reaches a specific threshold. A value of 0 (the default) disables the replication queue.</td>
</tr>
<tr>
<td>queue-flush-interval</td>
<td>long</td>
<td>10</td>
<td>Deprecated. In ASYNC mode, this attribute controls how often the asynchronous thread used to flush the replication queue runs. This should be a positive integer which represents thread wakeup time in milliseconds.</td>
</tr>
<tr>
<td>remote-timeout</td>
<td>long</td>
<td>15000</td>
<td>In SYNC mode, the timeout (in ms) used to wait for an acknowledgment when making a remote call, after which the call is aborted and an exception is thrown.</td>
</tr>
</table>
<div class="element">
<h3 class="heading">partition-handling?</h3>
<div class="content">
<p>
                   Configures the way this cache reacts to node crashes and split brains.
                </p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>enabled</td>
<td>boolean</td>
<td/>
<td>
                         Enable/disable the partition handling functionality. Defaults to false.
                      </td>
</tr>
</table>
</div>
</div>
<div>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>name</td>
<td>ID</td>
<td/>
<td>Uniquely identifies this cache within its cache container.</td>
</tr>
<tr>
<td>configuration</td>
<td>IDREF</td>
<td/>
<td>The name of the cache configuration which this configuration inherits from.</td>
</tr>
<tr>
<td>start</td>
<td>
<span class="error">FIXME</span>
</td>
<td/>
<td>Unused XML attribute</td>
</tr>
<tr>
<td>jndi-name</td>
<td>string</td>
<td/>
<td>Unused XML attribute</td>
</tr>
<tr>
<td>module</td>
<td>string</td>
<td/>
<td>Unused XML attribute</td>
</tr>
<tr>
<td>statistics</td>
<td>boolean</td>
<td>true</td>
<td>Determines whether or not the cache should collect statistics.  Keep disabled for optimal performance.</td>
</tr>
<tr>
<td>statistics-available</td>
<td>boolean</td>
<td>true</td>
<td>If set to false, statistics gathering cannot be enabled during runtime. Keep disabled for optimal performance.</td>
</tr>
<tr>
<td>deadlock-detection-spin</td>
<td>long</td>
<td>100</td>
<td>
          Time period that determines how often is lock acquisition attempted within maximum time allowed to acquire a particular lock. Defaults to 100ms.
        </td>
</tr>
<tr>
<td>unreliable-return-values</td>
<td>boolean</td>
<td>false</td>
<td>
          Specifies whether Infinispan is allowed to disregard the Map contract when providing return values for org.infinispan.Cache#put(Object, Object) and org.infinispan.Cache#remove(Object) methods.
        </td>
</tr>
</table>
<div class="element">
<h3 class="heading">backups?</h3>
<div class="content">
<p>The state transfer configuration for distribution and replicated caches.</p>
<div class="element">
<h3 class="heading">backup*</h3>
<div class="content">
<p>Configures a specific site where this cache backups data.</p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>site</td>
<td>string</td>
<td/>
<td>Name of the remote site where this cache backups data.</td>
</tr>
<tr>
<td>strategy</td>
<td>
<table class="enumeration">
<tr>
<td title="Enables asynchronous mode.">ASYNC</td>
<td>Enables asynchronous mode.</td>
</tr>
<tr>
<td title="Enables synchronous mode.">SYNC</td>
<td>Enables synchronous mode.</td>
</tr>
</table>
</td>
<td>ASYNC</td>
<td>The strategy used for backing up data: "SYNC" or "ASYNC". Defaults to "ASYNC"</td>
</tr>
<tr>
<td>failure-policy</td>
<td>
<table class="enumeration">
<tr>
<td title="Ignore backup failures.">IGNORE</td>
<td>Ignore backup failures.</td>
</tr>
<tr>
<td title="Warn of backup failures.">WARN</td>
<td>Warn of backup failures.</td>
</tr>
<tr>
<td title="Fail local operations when a backup failure occurs.">FAIL</td>
<td>Fail local operations when a backup failure occurs.</td>
</tr>
<tr>
<td title="Invoke a user-specified failure policy (set via the failure-policy-class attribute)">CUSTOM</td>
<td>Invoke a user-specified failure policy (set via the failure-policy-class attribute)</td>
</tr>
</table>
</td>
<td>WARN</td>
<td>Decides what the system would do in case of failure during backup. Defaults to "WARN"</td>
</tr>
<tr>
<td>timeout</td>
<td>long</td>
<td>10000</td>
<td>The timeout(millis) to be used when backing up data remotely. Defaults to 10 secs.</td>
</tr>
<tr>
<td>enabled</td>
<td>boolean</td>
<td>true</td>
<td>If 'false' then no data is backed up to this site. Defaults to 'true'.</td>
</tr>
<tr>
<td>two-phase-commit</td>
<td>boolean</td>
<td>false</td>
<td>
          Configures whether the replication happens in a 1PC or 2PC when using SYNC backup strategy. Defaults to "false".
          CacheConfigurationException is thrown when used with ASYNC backup strategy.
        </td>
</tr>
<tr>
<td>failure-policy-class</td>
<td>string</td>
<td/>
<td>
          If the 'backupFailurePolicy' is set to 'CUSTOM' then this attribute is
          required and should
          contain the fully qualified name of a class implementing
          org.infinispan.xsite.CustomFailurePolicy.
        </td>
</tr>
</table>
<div class="element">
<h3 class="heading">take-offline?</h3>
<div class="content">
<p>Determines whether this backup is taken offline (ignored) after a certain number of tries.</p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>after-failures</td>
<td>int</td>
<td>0</td>
<td>The number of failed request operations after which this site should be taken offline. Defaults to 0 (never). A negative value would mean that the site will be taken offline after 'min-wait'.</td>
</tr>
<tr>
<td>min-wait</td>
<td>long</td>
<td>0</td>
<td>The minimal number of millis to wait before taking this site offline, even in the case 'after-failures' is reached. If smaller or equal to 0, then only 'after-failures' is considered.</td>
</tr>
</table>
</div>
</div>
<div class="element">
<h3 class="heading">state-transfer?</h3>
<div class="content">
<p>
            Configures the properties needed to transfer the state for this site.
          </p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>chunk-size</td>
<td>int</td>
<td>512</td>
<td>
                If &gt; 0, the state will be transferred in batches of {@code chunkSize} cache entries.
                If &lt;= 0, the state will be transferred in all at once. Not recommended. Defaults to 512.
              </td>
</tr>
<tr>
<td>timeout</td>
<td>long</td>
<td>1200000</td>
<td>
                The time (in milliseconds) to wait for the backup site acknowledge the state chunk
                received and applied. Default value is 20 min.
              </td>
</tr>
<tr>
<td>max-retries</td>
<td>int</td>
<td>30</td>
<td>
                The maximum number of retries when a push state command fails. A value &lt;= 0 (zero) mean that
                the command will not retry. Default value is 30.
              </td>
</tr>
<tr>
<td>wait-time</td>
<td>long</td>
<td>2000</td>
<td>
                The waiting time (in milliseconds) between each retry. The value should be &gt; 0 (zero). Default
                value is 2 seconds.
              </td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="element">
<h3 class="heading">backup-for?</h3>
<div class="content">
<p>
            Configures this cache as a backup for a remote cache.
          </p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>remote-cache</td>
<td>string</td>
<td/>
<td>
                The name of the remote cache that backups data here.
              </td>
</tr>
<tr>
<td>remote-site</td>
<td>string</td>
<td/>
<td>
                The name of the remote site containing the cache that backups data here.
              </td>
</tr>
</table>
</div>
</div>
<div class="element">
<h3 class="heading">locking?</h3>
<div class="content">
<p>The locking configuration of the cache.</p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>isolation</td>
<td>
<table class="enumeration">
<tr>
<td title="No locking isolation will be performed. This is only valid in local mode. In clustered mode, READ_COMMITTED will be used instead.">NONE</td>
<td>No locking isolation will be performed. This is only valid in local mode. In clustered mode, READ_COMMITTED will be used instead.</td>
</tr>
<tr>
<td title="Unsupported. Actually configures READ_COMMITTED">READ_UNCOMMITTED</td>
<td>Unsupported. Actually configures READ_COMMITTED</td>
</tr>
<tr>
<td title="Read committed is an isolation level that guarantees that any data read is committed at the moment it is read. However, depending on the outcome of other transactions, successive reads may return different results">READ_COMMITTED</td>
<td>Read committed is an isolation level that guarantees that any data read is committed at the moment it is read. However, depending on the outcome of other transactions, successive reads may return different results</td>
</tr>
<tr>
<td title="Repeatable read is an isolation level that guarantees that any data read is committed at the moment it is read and that, within a transaction, successive reads will always return the same data.">REPEATABLE_READ</td>
<td>Repeatable read is an isolation level that guarantees that any data read is committed at the moment it is read and that, within a transaction, successive reads will always return the same data.</td>
</tr>
<tr>
<td title="Unsupported. Actually configures REPEATABLE_READ">SERIALIZABLE</td>
<td>Unsupported. Actually configures REPEATABLE_READ</td>
</tr>
</table>
</td>
<td>READ_COMMITTED</td>
<td>Sets the cache locking isolation level. Infinispan only supports READ_COMMITTED or REPEATABLE_READ isolation level.</td>
</tr>
<tr>
<td>striping</td>
<td>boolean</td>
<td>false</td>
<td>If true, a pool of shared locks is maintained for all entries that need to be locked. Otherwise, a lock is created per entry in the cache. Lock striping helps control memory footprint but may reduce concurrency in the system.</td>
</tr>
<tr>
<td>acquire-timeout</td>
<td>long</td>
<td>10000</td>
<td>Maximum time to attempt a particular lock acquisition.</td>
</tr>
<tr>
<td>concurrency-level</td>
<td>int</td>
<td>32</td>
<td>Concurrency level for lock containers. Adjust this value according to the number of concurrent threads interacting with Infinispan.</td>
</tr>
<tr>
<td>write-skew</td>
<td>boolean</td>
<td>false</td>
<td>
          This setting is only applicable in the case of REPEATABLE_READ. When write skew check is set to false, if the writer at commit time discovers that the working entry and the underlying entry have different versions, the working entry will overwrite the underlying entry. If true, such version conflict - known as a write-skew - will throw an Exception. Defaults to false.
        </td>
</tr>
</table>
</div>
</div>
<div class="element">
<h3 class="heading">transaction?</h3>
<div class="content">
<p>The cache transaction configuration.</p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>mode</td>
<td>
<table class="enumeration">
<tr>
<td title="Cache will not enlist within transactions.">NONE</td>
<td>Cache will not enlist within transactions.</td>
</tr>
<tr>
<td title="Uses batching to group cache operations together.">BATCH</td>
<td>Uses batching to group cache operations together.</td>
</tr>
<tr>
<td title="Cache will enlist within transactions as a javax.transaction.Synchronization">NON_XA</td>
<td>Cache will enlist within transactions as a javax.transaction.Synchronization</td>
</tr>
<tr>
<td title="Cache will enlist within transactions as a javax.transaction.xa.XAResource, without recovery.">NON_DURABLE_XA</td>
<td>Cache will enlist within transactions as a javax.transaction.xa.XAResource, without recovery.</td>
</tr>
<tr>
<td title="Cache will enlist within transactions as a javax.transaction.xa.XAResource, with recovery.">FULL_XA</td>
<td>Cache will enlist within transactions as a javax.transaction.xa.XAResource, with recovery.</td>
</tr>
</table>
</td>
<td>NONE</td>
<td>Sets the cache transaction mode to one of NONE, BATCH, NON_XA, NON_DURABLE_XA, FULL_XA.</td>
</tr>
<tr>
<td>stop-timeout</td>
<td>long</td>
<td>30000</td>
<td>If there are any ongoing transactions when a cache is stopped, Infinispan waits for ongoing remote and local transactions to finish. The amount of time to wait for is defined by the cache stop timeout.</td>
</tr>
<tr>
<td>locking</td>
<td>
<table class="enumeration">
<tr>
<td title="Enables Optimistic locking.">OPTIMISTIC</td>
<td>Enables Optimistic locking.</td>
</tr>
<tr>
<td title="Enables Pessimistic locking.">PESSIMISTIC</td>
<td>Enables Pessimistic locking.</td>
</tr>
</table>
</td>
<td>OPTIMISTIC</td>
<td>The locking mode for this cache, one of OPTIMISTIC or PESSIMISTIC.</td>
</tr>
<tr>
<td>transaction-manager-lookup</td>
<td>string</td>
<td>org.infinispan.transaction.lookup.GenericTransactionManagerLookup.GenericTransactionManagerLookup</td>
<td>
          Configure Transaction manager lookup directly using an instance of TransactionManagerLookup. Calling this method marks the cache as transactional.
        </td>
</tr>
<tr>
<td>complete-timeout</td>
<td>long</td>
<td>60000</td>
<td>
          The duration (millis) in which to keep information about the completion of a transaction. Defaults to 60000.
        </td>
</tr>
<tr>
<td>reaper-interval</td>
<td>long</td>
<td>30000</td>
<td>
          The time interval (millis) at which the thread that cleans up transaction completion information kicks in. Defaults to 30000.
        </td>
</tr>
<tr>
<td>auto-commit</td>
<td>boolean</td>
<td>true</td>
<td>
          If the cache is transactional and transactionAutoCommit is enabled then for single operation transactions the user doesn't need to manually start a transaction, but a transactions is injected by the system. Defaults to true.
        </td>
</tr>
<tr>
<td>protocol</td>
<td>
<table class="enumeration">
<tr>
<td title="">DEFAULT</td>
<td/>
</tr>
<tr>
<td title="">TOTAL_ORDER</td>
<td/>
</tr>
</table>
</td>
<td/>
<td>
          Configures the commit protocol to use.
        </td>
</tr>
<tr>
<td>recovery-cache</td>
<td>string</td>
<td>__recoveryInfoCacheName__</td>
<td>
          Sets the name of the cache where recovery related information is held. The cache's default name is "__recoveryInfoCacheName__"
        </td>
</tr>
<tr>
<td>notifications</td>
<td>boolean</td>
<td>true</td>
<td>
          Enables or disables triggering transactional notifications on cache listeners. By default is enabled.
        </td>
</tr>
</table>
</div>
</div>
<div class="element">
<h3 class="heading">eviction?</h3>
<div class="content">
<p>The cache eviction configuration.</p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>strategy</td>
<td>
<table class="enumeration">
<tr>
<td title="Never evict entries. This is the default.">NONE</td>
<td>Never evict entries. This is the default.</td>
</tr>
<tr>
<td title="Actually activates LRU.">UNORDERED</td>
<td>Actually activates LRU.</td>
</tr>
<tr>
<td title="Deprecated. Actually activates LRU.">FIFO</td>
<td>Deprecated. Actually activates LRU.</td>
</tr>
<tr>
<td title="Least-Recently Used policy.">LRU</td>
<td>Least-Recently Used policy.</td>
</tr>
<tr>
<td title="Low Inter-reference Recency Set. An improved version of LRU which uses cache-locality access information to better decide which data to evict.">LIRS</td>
<td>Low Inter-reference Recency Set. An improved version of LRU which uses cache-locality access information to better decide which data to evict.</td>
</tr>
<tr>
<td title="Eviction will be performed manually. Equivalent internally to NONE.">MANUAL</td>
<td>Eviction will be performed manually. Equivalent internally to NONE.</td>
</tr>
</table>
</td>
<td>NONE</td>
<td>Sets the cache eviction strategy. Available options are 'UNORDERED', 'FIFO', 'LRU', 'LIRS' and 'NONE' (to disable eviction).</td>
</tr>
<tr>
<td>max-entries</td>
<td>long</td>
<td>-1</td>
<td>Deprecated since 8.1. Use the size attribute instead.</td>
</tr>
<tr>
<td>thread-policy</td>
<td>
<table class="enumeration">
<tr>
<td title="Fires the eviction events from the same thread which is performing the eviction ">PIGGYBACK</td>
<td>Fires the eviction events from the same thread which is performing the eviction </td>
</tr>
<tr>
<td title="Use the default eviction listener thread policy (PIGGYBACK)">DEFAULT</td>
<td>Use the default eviction listener thread policy (PIGGYBACK)</td>
</tr>
</table>
</td>
<td>DEFAULT</td>
<td>
          Threading policy for eviction. Defaults to using the DEFAULT eviction policy.
        </td>
</tr>
<tr>
<td>type</td>
<td>
<table class="enumeration">
<tr>
<td title="Evicts entries from the cache when a specified count has been set">COUNT</td>
<td>Evicts entries from the cache when a specified count has been set</td>
</tr>
<tr>
<td title="Evicts entries from the cache when a specified memory usage has been reached. Memory usage is computed using an approximation which is tailored for the HotSpot VM. This can only be used when both key and values are stored as byte arrays. To guarantee only byte arrays are stored it is recommended to run with store as binary for both keys and values">MEMORY</td>
<td>Evicts entries from the cache when a specified memory usage has been reached. Memory usage is computed using an approximation which is tailored for the HotSpot VM. This can only be used when both key and values are stored as byte arrays. To guarantee only byte arrays are stored it is recommended to run with store as binary for both keys and values</td>
</tr>
</table>
</td>
<td>COUNT</td>
<td>Specifies whether to use entry count or memory-based approximation to decide when to evict entries.</td>
</tr>
<tr>
<td>size</td>
<td>long</td>
<td>-1</td>
<td>Maximum size to use for eviction. When using the COUNT type, this is the maximum number of entries in a cache instance. When using the MEMORY threshold policy, this is the maximum number of allocated bytes used by a cache's datacontainer. A value of -1 means no limit. This is currently limited to 2^48 - 1 in size.</td>
</tr>
</table>
</div>
</div>
<div class="element">
<h3 class="heading">expiration?</h3>
<div class="content">
<p>The cache expiration configuration.</p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>max-idle</td>
<td>long</td>
<td>-1</td>
<td>Maximum idle time a cache entry will be maintained in the cache, in milliseconds. If the idle time is exceeded, the entry will be expired cluster-wide. -1 means the entries never expire.</td>
</tr>
<tr>
<td>lifespan</td>
<td>long</td>
<td>-1</td>
<td>Maximum lifespan of a cache entry, after which the entry is expired cluster-wide, in milliseconds. -1 means the entries never expire.</td>
</tr>
<tr>
<td>interval</td>
<td>long</td>
<td>60000</td>
<td>Interval (in milliseconds) between subsequent runs to purge expired entries from memory and any cache stores. If you wish to disable the periodic eviction process altogether, set interval to -1.</td>
</tr>
</table>
</div>
</div>
<div class="element">
<h3 class="heading">compatibility?</h3>
<div class="content">
<p>The cache compatibility mode configuration.</p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>marshaller</td>
<td>string</td>
<td/>
<td>A marshaller to use for compatibility conversions.</td>
</tr>
</table>
</div>
</div>
<div class="element">
<h3 class="heading">store-as-binary?</h3>
<div class="content">
<p>Configures the cache to store data in binary format.</p>
        Controls whether when stored in memory, keys and values are stored as references to their original objects, or in a serialized, binary format.  There are benefits to both approaches, but often if used in a clustered mode, storing objects as binary means that the cost of serialization happens early on, and can be amortized.  Further, deserialization costs are incurred lazily which improves throughput. It is possible to control this on a fine-grained basis: you can choose to just store keys or values as binary, or both.
      <table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>keys</td>
<td>boolean</td>
<td>true</td>
<td>
          Specify whether keys are stored as binary or not. Enabled by default if the "enabled" attribute is set to true.
        </td>
</tr>
<tr>
<td>values</td>
<td>boolean</td>
<td>true</td>
<td>
          Specify whether values are stored as binary or not. Enabled by default if the "enabled" attribute is set to true.
        </td>
</tr>
</table>
</div>
</div>
<div class="element">
<h3 class="heading">persistence?</h3>
<div class="content">
<p>Configures the cache's persistence layer.</p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>passivation</td>
<td>boolean</td>
<td>false</td>
<td>
          If true, data is only written to the cache store when it is evicted from memory, a phenomenon known as 'passivation'. Next time the data is requested, it will be 'activated' which means that data will be brought back to memory and removed from the persistent store. This gives you the ability to 'overflow' to disk, similar to swapping in an operating system. If false, the cache store contains a copy of the contents in memory, so writes to cache result in cache store writes. This essentially gives you a 'write-through' configuration. Defaults to false.
        </td>
</tr>
</table>
</div>
</div>
<div class="element">
<h3 class="heading">versioning?</h3>
<div class="content">
<p>
            Controls whether entries are versioned.  Versioning is necessary, for example, when using optimistic transactions in a clustered environment, to be able to perform write-skew checks.
          </p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>scheme</td>
<td>
<table class="enumeration">
<tr>
<td title="&#10;            A simple versioning scheme that is cluster-aware&#10;          ">SIMPLE</td>
<td>
            A simple versioning scheme that is cluster-aware
          </td>
</tr>
<tr>
<td title="&#10;            Don't version entries&#10;          ">NONE</td>
<td>
            Don't version entries
          </td>
</tr>
</table>
</td>
<td>NONE</td>
<td>
          The scheme to use when versioning entries. Can be either SIMPLE or NONE. Defaults to NONE
        </td>
</tr>
</table>
</div>
</div>
<div class="element">
<h3 class="heading">data-container?</h3>
<div class="content">
<p>
            Controls the data container for the cache.
          </p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>class</td>
<td>string</td>
<td/>
<td>
          DEPRECATED: this is to be removed in a future release
          Fully qualified class name of the data container to use
        </td>
</tr>
<tr>
<td>key-equivalence</td>
<td>string</td>
<td/>
<td>
          Fully qualified class name of the Equivalence class to use
          for keys stored in the cache, which provides with custom
          ways to compare cached keys
        </td>
</tr>
<tr>
<td>value-equivalence</td>
<td>string</td>
<td/>
<td>
          Fully qualified class name of the Equivalence class to use
          for values stored in the cache, which provides with custom
          ways to compare cached values
        </td>
</tr>
</table>
<div class="element">
<h3 class="heading">property*</h3>
<div class="content">
<p>Properties passed to the data container</p>
</div>
</div>
</div>
</div>
<div class="element">
<h3 class="heading">modules?</h3>
<div class="content">
<p>
            This element contains configuration options for additional modules which affect cache configuration
          </p>
</div>
</div>
<div class="element">
<h3 class="heading">indexing?</h3>
<div class="content">
<p>
            Defines indexing options for cache
          </p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>index</td>
<td>
<table class="enumeration">
<tr>
<td title="Do not index data. This is the default.">NONE</td>
<td>Do not index data. This is the default.</td>
</tr>
<tr>
<td title="Only index changes made locally, ignoring remote changes. This is useful if indexes are shared across a cluster to prevent redundant indexing of updates.">LOCAL</td>
<td>Only index changes made locally, ignoring remote changes. This is useful if indexes are shared across a cluster to prevent redundant indexing of updates.</td>
</tr>
<tr>
<td title="Index all data">ALL</td>
<td>Index all data</td>
</tr>
</table>
</td>
<td>NONE</td>
<td>The indexing mode of the cache. Defaults to NONE.</td>
</tr>
<tr>
<td>auto-config</td>
<td>boolean</td>
<td>false</td>
<td>Whether or not to apply automatic index configuration based on cache type</td>
</tr>
</table>
<div class="element">
<h3 class="heading">indexed-entities?</h3>
<div class="content">
<p>Defines the indexed entity classes</p>
<div class="element">
<h3 class="heading">indexed-entity*</h3>
<div class="content">
<p>Indexed entity class name</p>
</div>
</div>
</div>
</div>
<div class="element">
<h3 class="heading">property*</h3>
<div class="content">
<p>Property to pass on to the indexing system</p>
</div>
</div>
</div>
</div>
<div class="element">
<h3 class="heading">custom-interceptors?</h3>
<div class="content">
<p>Configures custom interceptors to be added to the cache.</p>
<div class="element">
<h3 class="heading">interceptor*</h3>
<div class="content">
<p/>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>after</td>
<td>string</td>
<td/>
<td>Dictates that the custom interceptor appears immediately after the specified interceptor. If the specified interceptor is not found in the interceptor chain, a ConfigurationException will be thrown when the cache starts.</td>
</tr>
<tr>
<td>before</td>
<td>string</td>
<td/>
<td>Dictates that the custom interceptor appears immediately before the specified interceptor. If the specified interceptor is not found in the interceptor chain, a ConfigurationException will be thrown when the cache starts.</td>
</tr>
<tr>
<td>class</td>
<td>string</td>
<td/>
<td>A fully qualified class name of the new custom interceptor to add to the configuration.</td>
</tr>
<tr>
<td>index</td>
<td>int</td>
<td/>
<td>Specifies a position in the interceptor chain to place the new interceptor. The index starts at 0 and goes up to the number of interceptors in a given configuration. A ConfigurationException is thrown if the index is less than 0 or greater than the maximum number of interceptors in the chain.</td>
</tr>
<tr>
<td>position</td>
<td>string</td>
<td/>
<td>Specifies a position where to place the new interceptor. Allowed values are FIRST, LAST, and OTHER_THAN_FIRST_OR_LAST</td>
</tr>
</table>
<div class="element">
<h3 class="heading">property?</h3>
<div class="content">
<p/>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="element">
<h3 class="heading">security?</h3>
<div class="content">
<p>Configures cache-level security.</p>
<div class="element">
<h3 class="heading">authorization?</h3>
<div class="content">
<p>
            Configures authorization for this cache.
          </p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>enabled</td>
<td>boolean</td>
<td>true</td>
<td>
                Enables authorization checks for this cache. Defaults to true if the authorization element is present.
              </td>
</tr>
<tr>
<td>roles</td>
<td/>
<td/>
<td>
                Sets the valid roles required to access this cache.
              </td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
        <div class="element">
<h3 class="heading">distributed-cache</h3>
<div class="content">
<p>Defines a DIST_* mode cache.</p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>owners</td>
<td>int</td>
<td>2</td>
<td>Number of cluster-wide replicas for each cache entry.</td>
</tr>
<tr>
<td>segments</td>
<td>int</td>
<td>256</td>
<td>Number of hash space segments (per cluster). The default value is 256, and should be at least 20 * cluster size.</td>
</tr>
<tr>
<td>capacity-factor</td>
<td>double</td>
<td>1</td>
<td>Controls the proportion of entries that will reside on the local node,
              compared to the other nodes in the cluster. Value must be positive. The default is 1</td>
</tr>
<tr>
<td>l1-lifespan</td>
<td>long</td>
<td/>
<td>Maximum lifespan in milliseconds of an entry placed in the L1 cache.
               By default L1 is disabled unless a positive value is configured for this attribute.
               If the attribute is not present, L1 is disabled.</td>
</tr>
<tr>
<td>l1-cleanup-interval</td>
<td>long</td>
<td>60000</td>
<td>
              Controls how often a cleanup task to prune L1 tracking data is run. Defaults to 10 minutes.
            </td>
</tr>
<tr>
<td>capacity</td>
<td>float</td>
<td>1</td>
<td>
              Controls the proportion of entries that will reside on the local node, compared to the other nodes
              in the cluster. This is just a suggestion, there is no guarantee that a node with a capacity
              factor of 2 will have twice as many entries as a node with a capacity factor of 1.
            </td>
</tr>
<tr>
<td>consistent-hash-factory</td>
<td>string</td>
<td/>
<td>
              The factory to use for generating the consistent hash.
              Must implement `org.infinispan.distribution.ch.ConsistentHashFactory`.
              E.g. `org.infinispan.distribution.ch.impl.SyncConsistentHashFactory` can be used to guarantee
              that multiple distributed caches use exactly the same consistent hash, which for performance
              reasons is not guaranteed by the default consistent hash factory instance used.
            </td>
</tr>
<tr>
<td>key-partitioner</td>
<td>string</td>
<td/>
<td>
              The name of the key partitioner class.
              Must implement `org.infinispan.distribution.ch.KeyPartitioner`.
              A custom key partitioner can be used as an alternative to grouping, to guarantee that some keys
              are located in the same segment (and thus their primary owner is the same node).
              Since 8.2.
            </td>
</tr>
</table>
<div class="element">
<h3 class="heading">state-transfer?</h3>
<div class="content">
<p>The state transfer configuration for distribution and replicated caches.</p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>enabled</td>
<td>boolean</td>
<td>true</td>
<td>If enabled, this will cause the cache to ask neighboring caches for state when it starts up, so the cache starts 'warm', although it will impact startup time.</td>
</tr>
<tr>
<td>timeout</td>
<td>long</td>
<td>240000</td>
<td>The maximum amount of time (ms) to wait for state from neighboring caches, before throwing an exception and aborting startup.</td>
</tr>
<tr>
<td>chunk-size</td>
<td>integer</td>
<td>512</td>
<td>The number of cache entries to batch in each transfer.</td>
</tr>
<tr>
<td>await-initial-transfer</td>
<td>boolean</td>
<td>true</td>
<td>If enabled, this will cause the cache to wait for initial state transfer to complete before responding to requests.</td>
</tr>
</table>
</div>
</div>
<div class="element">
<h3 class="heading">groups?</h3>
<div class="content">
<p>Configures grouping of data.</p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>enabled</td>
<td>boolean</td>
<td/>
<td>
          Enables or disables grouping.
        </td>
</tr>
</table>
<div class="element">
<h3 class="heading">grouper*</h3>
<div class="content">
<p/>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>class</td>
<td>string</td>
<td/>
<td>
                The class to use to group keys. Must implement org.infinispan.distribution.group.Grouper.
              </td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>mode</td>
<td>
<table class="enumeration">
<tr>
<td title="Enables asynchronous mode.">ASYNC</td>
<td>Enables asynchronous mode.</td>
</tr>
<tr>
<td title="Enables synchronous mode.">SYNC</td>
<td>Enables synchronous mode.</td>
</tr>
</table>
</td>
<td/>
<td>Sets the clustered cache mode, ASYNC for asynchronous operation, or SYNC for synchronous operation.</td>
</tr>
<tr>
<td>queue-size</td>
<td>int</td>
<td>0</td>
<td>Deprecated. In ASYNC mode, this attribute can be used to trigger flushing of the queue when it reaches a specific threshold. A value of 0 (the default) disables the replication queue.</td>
</tr>
<tr>
<td>queue-flush-interval</td>
<td>long</td>
<td>10</td>
<td>Deprecated. In ASYNC mode, this attribute controls how often the asynchronous thread used to flush the replication queue runs. This should be a positive integer which represents thread wakeup time in milliseconds.</td>
</tr>
<tr>
<td>remote-timeout</td>
<td>long</td>
<td>15000</td>
<td>In SYNC mode, the timeout (in ms) used to wait for an acknowledgment when making a remote call, after which the call is aborted and an exception is thrown.</td>
</tr>
</table>
<div class="element">
<h3 class="heading">partition-handling?</h3>
<div class="content">
<p>
                   Configures the way this cache reacts to node crashes and split brains.
                </p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>enabled</td>
<td>boolean</td>
<td/>
<td>
                         Enable/disable the partition handling functionality. Defaults to false.
                      </td>
</tr>
</table>
</div>
</div>
<div>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>name</td>
<td>ID</td>
<td/>
<td>Uniquely identifies this cache within its cache container.</td>
</tr>
<tr>
<td>configuration</td>
<td>IDREF</td>
<td/>
<td>The name of the cache configuration which this configuration inherits from.</td>
</tr>
<tr>
<td>start</td>
<td>
<span class="error">FIXME</span>
</td>
<td/>
<td>Unused XML attribute</td>
</tr>
<tr>
<td>jndi-name</td>
<td>string</td>
<td/>
<td>Unused XML attribute</td>
</tr>
<tr>
<td>module</td>
<td>string</td>
<td/>
<td>Unused XML attribute</td>
</tr>
<tr>
<td>statistics</td>
<td>boolean</td>
<td>true</td>
<td>Determines whether or not the cache should collect statistics.  Keep disabled for optimal performance.</td>
</tr>
<tr>
<td>statistics-available</td>
<td>boolean</td>
<td>true</td>
<td>If set to false, statistics gathering cannot be enabled during runtime. Keep disabled for optimal performance.</td>
</tr>
<tr>
<td>deadlock-detection-spin</td>
<td>long</td>
<td>100</td>
<td>
          Time period that determines how often is lock acquisition attempted within maximum time allowed to acquire a particular lock. Defaults to 100ms.
        </td>
</tr>
<tr>
<td>unreliable-return-values</td>
<td>boolean</td>
<td>false</td>
<td>
          Specifies whether Infinispan is allowed to disregard the Map contract when providing return values for org.infinispan.Cache#put(Object, Object) and org.infinispan.Cache#remove(Object) methods.
        </td>
</tr>
</table>
<div class="element">
<h3 class="heading">backups?</h3>
<div class="content">
<p>The state transfer configuration for distribution and replicated caches.</p>
<div class="element">
<h3 class="heading">backup*</h3>
<div class="content">
<p>Configures a specific site where this cache backups data.</p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>site</td>
<td>string</td>
<td/>
<td>Name of the remote site where this cache backups data.</td>
</tr>
<tr>
<td>strategy</td>
<td>
<table class="enumeration">
<tr>
<td title="Enables asynchronous mode.">ASYNC</td>
<td>Enables asynchronous mode.</td>
</tr>
<tr>
<td title="Enables synchronous mode.">SYNC</td>
<td>Enables synchronous mode.</td>
</tr>
</table>
</td>
<td>ASYNC</td>
<td>The strategy used for backing up data: "SYNC" or "ASYNC". Defaults to "ASYNC"</td>
</tr>
<tr>
<td>failure-policy</td>
<td>
<table class="enumeration">
<tr>
<td title="Ignore backup failures.">IGNORE</td>
<td>Ignore backup failures.</td>
</tr>
<tr>
<td title="Warn of backup failures.">WARN</td>
<td>Warn of backup failures.</td>
</tr>
<tr>
<td title="Fail local operations when a backup failure occurs.">FAIL</td>
<td>Fail local operations when a backup failure occurs.</td>
</tr>
<tr>
<td title="Invoke a user-specified failure policy (set via the failure-policy-class attribute)">CUSTOM</td>
<td>Invoke a user-specified failure policy (set via the failure-policy-class attribute)</td>
</tr>
</table>
</td>
<td>WARN</td>
<td>Decides what the system would do in case of failure during backup. Defaults to "WARN"</td>
</tr>
<tr>
<td>timeout</td>
<td>long</td>
<td>10000</td>
<td>The timeout(millis) to be used when backing up data remotely. Defaults to 10 secs.</td>
</tr>
<tr>
<td>enabled</td>
<td>boolean</td>
<td>true</td>
<td>If 'false' then no data is backed up to this site. Defaults to 'true'.</td>
</tr>
<tr>
<td>two-phase-commit</td>
<td>boolean</td>
<td>false</td>
<td>
          Configures whether the replication happens in a 1PC or 2PC when using SYNC backup strategy. Defaults to "false".
          CacheConfigurationException is thrown when used with ASYNC backup strategy.
        </td>
</tr>
<tr>
<td>failure-policy-class</td>
<td>string</td>
<td/>
<td>
          If the 'backupFailurePolicy' is set to 'CUSTOM' then this attribute is
          required and should
          contain the fully qualified name of a class implementing
          org.infinispan.xsite.CustomFailurePolicy.
        </td>
</tr>
</table>
<div class="element">
<h3 class="heading">take-offline?</h3>
<div class="content">
<p>Determines whether this backup is taken offline (ignored) after a certain number of tries.</p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>after-failures</td>
<td>int</td>
<td>0</td>
<td>The number of failed request operations after which this site should be taken offline. Defaults to 0 (never). A negative value would mean that the site will be taken offline after 'min-wait'.</td>
</tr>
<tr>
<td>min-wait</td>
<td>long</td>
<td>0</td>
<td>The minimal number of millis to wait before taking this site offline, even in the case 'after-failures' is reached. If smaller or equal to 0, then only 'after-failures' is considered.</td>
</tr>
</table>
</div>
</div>
<div class="element">
<h3 class="heading">state-transfer?</h3>
<div class="content">
<p>
            Configures the properties needed to transfer the state for this site.
          </p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>chunk-size</td>
<td>int</td>
<td>512</td>
<td>
                If &gt; 0, the state will be transferred in batches of {@code chunkSize} cache entries.
                If &lt;= 0, the state will be transferred in all at once. Not recommended. Defaults to 512.
              </td>
</tr>
<tr>
<td>timeout</td>
<td>long</td>
<td>1200000</td>
<td>
                The time (in milliseconds) to wait for the backup site acknowledge the state chunk
                received and applied. Default value is 20 min.
              </td>
</tr>
<tr>
<td>max-retries</td>
<td>int</td>
<td>30</td>
<td>
                The maximum number of retries when a push state command fails. A value &lt;= 0 (zero) mean that
                the command will not retry. Default value is 30.
              </td>
</tr>
<tr>
<td>wait-time</td>
<td>long</td>
<td>2000</td>
<td>
                The waiting time (in milliseconds) between each retry. The value should be &gt; 0 (zero). Default
                value is 2 seconds.
              </td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="element">
<h3 class="heading">backup-for?</h3>
<div class="content">
<p>
            Configures this cache as a backup for a remote cache.
          </p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>remote-cache</td>
<td>string</td>
<td/>
<td>
                The name of the remote cache that backups data here.
              </td>
</tr>
<tr>
<td>remote-site</td>
<td>string</td>
<td/>
<td>
                The name of the remote site containing the cache that backups data here.
              </td>
</tr>
</table>
</div>
</div>
<div class="element">
<h3 class="heading">locking?</h3>
<div class="content">
<p>The locking configuration of the cache.</p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>isolation</td>
<td>
<table class="enumeration">
<tr>
<td title="No locking isolation will be performed. This is only valid in local mode. In clustered mode, READ_COMMITTED will be used instead.">NONE</td>
<td>No locking isolation will be performed. This is only valid in local mode. In clustered mode, READ_COMMITTED will be used instead.</td>
</tr>
<tr>
<td title="Unsupported. Actually configures READ_COMMITTED">READ_UNCOMMITTED</td>
<td>Unsupported. Actually configures READ_COMMITTED</td>
</tr>
<tr>
<td title="Read committed is an isolation level that guarantees that any data read is committed at the moment it is read. However, depending on the outcome of other transactions, successive reads may return different results">READ_COMMITTED</td>
<td>Read committed is an isolation level that guarantees that any data read is committed at the moment it is read. However, depending on the outcome of other transactions, successive reads may return different results</td>
</tr>
<tr>
<td title="Repeatable read is an isolation level that guarantees that any data read is committed at the moment it is read and that, within a transaction, successive reads will always return the same data.">REPEATABLE_READ</td>
<td>Repeatable read is an isolation level that guarantees that any data read is committed at the moment it is read and that, within a transaction, successive reads will always return the same data.</td>
</tr>
<tr>
<td title="Unsupported. Actually configures REPEATABLE_READ">SERIALIZABLE</td>
<td>Unsupported. Actually configures REPEATABLE_READ</td>
</tr>
</table>
</td>
<td>READ_COMMITTED</td>
<td>Sets the cache locking isolation level. Infinispan only supports READ_COMMITTED or REPEATABLE_READ isolation level.</td>
</tr>
<tr>
<td>striping</td>
<td>boolean</td>
<td>false</td>
<td>If true, a pool of shared locks is maintained for all entries that need to be locked. Otherwise, a lock is created per entry in the cache. Lock striping helps control memory footprint but may reduce concurrency in the system.</td>
</tr>
<tr>
<td>acquire-timeout</td>
<td>long</td>
<td>10000</td>
<td>Maximum time to attempt a particular lock acquisition.</td>
</tr>
<tr>
<td>concurrency-level</td>
<td>int</td>
<td>32</td>
<td>Concurrency level for lock containers. Adjust this value according to the number of concurrent threads interacting with Infinispan.</td>
</tr>
<tr>
<td>write-skew</td>
<td>boolean</td>
<td>false</td>
<td>
          This setting is only applicable in the case of REPEATABLE_READ. When write skew check is set to false, if the writer at commit time discovers that the working entry and the underlying entry have different versions, the working entry will overwrite the underlying entry. If true, such version conflict - known as a write-skew - will throw an Exception. Defaults to false.
        </td>
</tr>
</table>
</div>
</div>
<div class="element">
<h3 class="heading">transaction?</h3>
<div class="content">
<p>The cache transaction configuration.</p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>mode</td>
<td>
<table class="enumeration">
<tr>
<td title="Cache will not enlist within transactions.">NONE</td>
<td>Cache will not enlist within transactions.</td>
</tr>
<tr>
<td title="Uses batching to group cache operations together.">BATCH</td>
<td>Uses batching to group cache operations together.</td>
</tr>
<tr>
<td title="Cache will enlist within transactions as a javax.transaction.Synchronization">NON_XA</td>
<td>Cache will enlist within transactions as a javax.transaction.Synchronization</td>
</tr>
<tr>
<td title="Cache will enlist within transactions as a javax.transaction.xa.XAResource, without recovery.">NON_DURABLE_XA</td>
<td>Cache will enlist within transactions as a javax.transaction.xa.XAResource, without recovery.</td>
</tr>
<tr>
<td title="Cache will enlist within transactions as a javax.transaction.xa.XAResource, with recovery.">FULL_XA</td>
<td>Cache will enlist within transactions as a javax.transaction.xa.XAResource, with recovery.</td>
</tr>
</table>
</td>
<td>NONE</td>
<td>Sets the cache transaction mode to one of NONE, BATCH, NON_XA, NON_DURABLE_XA, FULL_XA.</td>
</tr>
<tr>
<td>stop-timeout</td>
<td>long</td>
<td>30000</td>
<td>If there are any ongoing transactions when a cache is stopped, Infinispan waits for ongoing remote and local transactions to finish. The amount of time to wait for is defined by the cache stop timeout.</td>
</tr>
<tr>
<td>locking</td>
<td>
<table class="enumeration">
<tr>
<td title="Enables Optimistic locking.">OPTIMISTIC</td>
<td>Enables Optimistic locking.</td>
</tr>
<tr>
<td title="Enables Pessimistic locking.">PESSIMISTIC</td>
<td>Enables Pessimistic locking.</td>
</tr>
</table>
</td>
<td>OPTIMISTIC</td>
<td>The locking mode for this cache, one of OPTIMISTIC or PESSIMISTIC.</td>
</tr>
<tr>
<td>transaction-manager-lookup</td>
<td>string</td>
<td>org.infinispan.transaction.lookup.GenericTransactionManagerLookup.GenericTransactionManagerLookup</td>
<td>
          Configure Transaction manager lookup directly using an instance of TransactionManagerLookup. Calling this method marks the cache as transactional.
        </td>
</tr>
<tr>
<td>complete-timeout</td>
<td>long</td>
<td>60000</td>
<td>
          The duration (millis) in which to keep information about the completion of a transaction. Defaults to 60000.
        </td>
</tr>
<tr>
<td>reaper-interval</td>
<td>long</td>
<td>30000</td>
<td>
          The time interval (millis) at which the thread that cleans up transaction completion information kicks in. Defaults to 30000.
        </td>
</tr>
<tr>
<td>auto-commit</td>
<td>boolean</td>
<td>true</td>
<td>
          If the cache is transactional and transactionAutoCommit is enabled then for single operation transactions the user doesn't need to manually start a transaction, but a transactions is injected by the system. Defaults to true.
        </td>
</tr>
<tr>
<td>protocol</td>
<td>
<table class="enumeration">
<tr>
<td title="">DEFAULT</td>
<td/>
</tr>
<tr>
<td title="">TOTAL_ORDER</td>
<td/>
</tr>
</table>
</td>
<td/>
<td>
          Configures the commit protocol to use.
        </td>
</tr>
<tr>
<td>recovery-cache</td>
<td>string</td>
<td>__recoveryInfoCacheName__</td>
<td>
          Sets the name of the cache where recovery related information is held. The cache's default name is "__recoveryInfoCacheName__"
        </td>
</tr>
<tr>
<td>notifications</td>
<td>boolean</td>
<td>true</td>
<td>
          Enables or disables triggering transactional notifications on cache listeners. By default is enabled.
        </td>
</tr>
</table>
</div>
</div>
<div class="element">
<h3 class="heading">eviction?</h3>
<div class="content">
<p>The cache eviction configuration.</p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>strategy</td>
<td>
<table class="enumeration">
<tr>
<td title="Never evict entries. This is the default.">NONE</td>
<td>Never evict entries. This is the default.</td>
</tr>
<tr>
<td title="Actually activates LRU.">UNORDERED</td>
<td>Actually activates LRU.</td>
</tr>
<tr>
<td title="Deprecated. Actually activates LRU.">FIFO</td>
<td>Deprecated. Actually activates LRU.</td>
</tr>
<tr>
<td title="Least-Recently Used policy.">LRU</td>
<td>Least-Recently Used policy.</td>
</tr>
<tr>
<td title="Low Inter-reference Recency Set. An improved version of LRU which uses cache-locality access information to better decide which data to evict.">LIRS</td>
<td>Low Inter-reference Recency Set. An improved version of LRU which uses cache-locality access information to better decide which data to evict.</td>
</tr>
<tr>
<td title="Eviction will be performed manually. Equivalent internally to NONE.">MANUAL</td>
<td>Eviction will be performed manually. Equivalent internally to NONE.</td>
</tr>
</table>
</td>
<td>NONE</td>
<td>Sets the cache eviction strategy. Available options are 'UNORDERED', 'FIFO', 'LRU', 'LIRS' and 'NONE' (to disable eviction).</td>
</tr>
<tr>
<td>max-entries</td>
<td>long</td>
<td>-1</td>
<td>Deprecated since 8.1. Use the size attribute instead.</td>
</tr>
<tr>
<td>thread-policy</td>
<td>
<table class="enumeration">
<tr>
<td title="Fires the eviction events from the same thread which is performing the eviction ">PIGGYBACK</td>
<td>Fires the eviction events from the same thread which is performing the eviction </td>
</tr>
<tr>
<td title="Use the default eviction listener thread policy (PIGGYBACK)">DEFAULT</td>
<td>Use the default eviction listener thread policy (PIGGYBACK)</td>
</tr>
</table>
</td>
<td>DEFAULT</td>
<td>
          Threading policy for eviction. Defaults to using the DEFAULT eviction policy.
        </td>
</tr>
<tr>
<td>type</td>
<td>
<table class="enumeration">
<tr>
<td title="Evicts entries from the cache when a specified count has been set">COUNT</td>
<td>Evicts entries from the cache when a specified count has been set</td>
</tr>
<tr>
<td title="Evicts entries from the cache when a specified memory usage has been reached. Memory usage is computed using an approximation which is tailored for the HotSpot VM. This can only be used when both key and values are stored as byte arrays. To guarantee only byte arrays are stored it is recommended to run with store as binary for both keys and values">MEMORY</td>
<td>Evicts entries from the cache when a specified memory usage has been reached. Memory usage is computed using an approximation which is tailored for the HotSpot VM. This can only be used when both key and values are stored as byte arrays. To guarantee only byte arrays are stored it is recommended to run with store as binary for both keys and values</td>
</tr>
</table>
</td>
<td>COUNT</td>
<td>Specifies whether to use entry count or memory-based approximation to decide when to evict entries.</td>
</tr>
<tr>
<td>size</td>
<td>long</td>
<td>-1</td>
<td>Maximum size to use for eviction. When using the COUNT type, this is the maximum number of entries in a cache instance. When using the MEMORY threshold policy, this is the maximum number of allocated bytes used by a cache's datacontainer. A value of -1 means no limit. This is currently limited to 2^48 - 1 in size.</td>
</tr>
</table>
</div>
</div>
<div class="element">
<h3 class="heading">expiration?</h3>
<div class="content">
<p>The cache expiration configuration.</p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>max-idle</td>
<td>long</td>
<td>-1</td>
<td>Maximum idle time a cache entry will be maintained in the cache, in milliseconds. If the idle time is exceeded, the entry will be expired cluster-wide. -1 means the entries never expire.</td>
</tr>
<tr>
<td>lifespan</td>
<td>long</td>
<td>-1</td>
<td>Maximum lifespan of a cache entry, after which the entry is expired cluster-wide, in milliseconds. -1 means the entries never expire.</td>
</tr>
<tr>
<td>interval</td>
<td>long</td>
<td>60000</td>
<td>Interval (in milliseconds) between subsequent runs to purge expired entries from memory and any cache stores. If you wish to disable the periodic eviction process altogether, set interval to -1.</td>
</tr>
</table>
</div>
</div>
<div class="element">
<h3 class="heading">compatibility?</h3>
<div class="content">
<p>The cache compatibility mode configuration.</p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>marshaller</td>
<td>string</td>
<td/>
<td>A marshaller to use for compatibility conversions.</td>
</tr>
</table>
</div>
</div>
<div class="element">
<h3 class="heading">store-as-binary?</h3>
<div class="content">
<p>Configures the cache to store data in binary format.</p>
        Controls whether when stored in memory, keys and values are stored as references to their original objects, or in a serialized, binary format.  There are benefits to both approaches, but often if used in a clustered mode, storing objects as binary means that the cost of serialization happens early on, and can be amortized.  Further, deserialization costs are incurred lazily which improves throughput. It is possible to control this on a fine-grained basis: you can choose to just store keys or values as binary, or both.
      <table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>keys</td>
<td>boolean</td>
<td>true</td>
<td>
          Specify whether keys are stored as binary or not. Enabled by default if the "enabled" attribute is set to true.
        </td>
</tr>
<tr>
<td>values</td>
<td>boolean</td>
<td>true</td>
<td>
          Specify whether values are stored as binary or not. Enabled by default if the "enabled" attribute is set to true.
        </td>
</tr>
</table>
</div>
</div>
<div class="element">
<h3 class="heading">persistence?</h3>
<div class="content">
<p>Configures the cache's persistence layer.</p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>passivation</td>
<td>boolean</td>
<td>false</td>
<td>
          If true, data is only written to the cache store when it is evicted from memory, a phenomenon known as 'passivation'. Next time the data is requested, it will be 'activated' which means that data will be brought back to memory and removed from the persistent store. This gives you the ability to 'overflow' to disk, similar to swapping in an operating system. If false, the cache store contains a copy of the contents in memory, so writes to cache result in cache store writes. This essentially gives you a 'write-through' configuration. Defaults to false.
        </td>
</tr>
</table>
</div>
</div>
<div class="element">
<h3 class="heading">versioning?</h3>
<div class="content">
<p>
            Controls whether entries are versioned.  Versioning is necessary, for example, when using optimistic transactions in a clustered environment, to be able to perform write-skew checks.
          </p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>scheme</td>
<td>
<table class="enumeration">
<tr>
<td title="&#10;            A simple versioning scheme that is cluster-aware&#10;          ">SIMPLE</td>
<td>
            A simple versioning scheme that is cluster-aware
          </td>
</tr>
<tr>
<td title="&#10;            Don't version entries&#10;          ">NONE</td>
<td>
            Don't version entries
          </td>
</tr>
</table>
</td>
<td>NONE</td>
<td>
          The scheme to use when versioning entries. Can be either SIMPLE or NONE. Defaults to NONE
        </td>
</tr>
</table>
</div>
</div>
<div class="element">
<h3 class="heading">data-container?</h3>
<div class="content">
<p>
            Controls the data container for the cache.
          </p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>class</td>
<td>string</td>
<td/>
<td>
          DEPRECATED: this is to be removed in a future release
          Fully qualified class name of the data container to use
        </td>
</tr>
<tr>
<td>key-equivalence</td>
<td>string</td>
<td/>
<td>
          Fully qualified class name of the Equivalence class to use
          for keys stored in the cache, which provides with custom
          ways to compare cached keys
        </td>
</tr>
<tr>
<td>value-equivalence</td>
<td>string</td>
<td/>
<td>
          Fully qualified class name of the Equivalence class to use
          for values stored in the cache, which provides with custom
          ways to compare cached values
        </td>
</tr>
</table>
<div class="element">
<h3 class="heading">property*</h3>
<div class="content">
<p>Properties passed to the data container</p>
</div>
</div>
</div>
</div>
<div class="element">
<h3 class="heading">modules?</h3>
<div class="content">
<p>
            This element contains configuration options for additional modules which affect cache configuration
          </p>
</div>
</div>
<div class="element">
<h3 class="heading">indexing?</h3>
<div class="content">
<p>
            Defines indexing options for cache
          </p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>index</td>
<td>
<table class="enumeration">
<tr>
<td title="Do not index data. This is the default.">NONE</td>
<td>Do not index data. This is the default.</td>
</tr>
<tr>
<td title="Only index changes made locally, ignoring remote changes. This is useful if indexes are shared across a cluster to prevent redundant indexing of updates.">LOCAL</td>
<td>Only index changes made locally, ignoring remote changes. This is useful if indexes are shared across a cluster to prevent redundant indexing of updates.</td>
</tr>
<tr>
<td title="Index all data">ALL</td>
<td>Index all data</td>
</tr>
</table>
</td>
<td>NONE</td>
<td>The indexing mode of the cache. Defaults to NONE.</td>
</tr>
<tr>
<td>auto-config</td>
<td>boolean</td>
<td>false</td>
<td>Whether or not to apply automatic index configuration based on cache type</td>
</tr>
</table>
<div class="element">
<h3 class="heading">indexed-entities?</h3>
<div class="content">
<p>Defines the indexed entity classes</p>
<div class="element">
<h3 class="heading">indexed-entity*</h3>
<div class="content">
<p>Indexed entity class name</p>
</div>
</div>
</div>
</div>
<div class="element">
<h3 class="heading">property*</h3>
<div class="content">
<p>Property to pass on to the indexing system</p>
</div>
</div>
</div>
</div>
<div class="element">
<h3 class="heading">custom-interceptors?</h3>
<div class="content">
<p>Configures custom interceptors to be added to the cache.</p>
<div class="element">
<h3 class="heading">interceptor*</h3>
<div class="content">
<p/>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>after</td>
<td>string</td>
<td/>
<td>Dictates that the custom interceptor appears immediately after the specified interceptor. If the specified interceptor is not found in the interceptor chain, a ConfigurationException will be thrown when the cache starts.</td>
</tr>
<tr>
<td>before</td>
<td>string</td>
<td/>
<td>Dictates that the custom interceptor appears immediately before the specified interceptor. If the specified interceptor is not found in the interceptor chain, a ConfigurationException will be thrown when the cache starts.</td>
</tr>
<tr>
<td>class</td>
<td>string</td>
<td/>
<td>A fully qualified class name of the new custom interceptor to add to the configuration.</td>
</tr>
<tr>
<td>index</td>
<td>int</td>
<td/>
<td>Specifies a position in the interceptor chain to place the new interceptor. The index starts at 0 and goes up to the number of interceptors in a given configuration. A ConfigurationException is thrown if the index is less than 0 or greater than the maximum number of interceptors in the chain.</td>
</tr>
<tr>
<td>position</td>
<td>string</td>
<td/>
<td>Specifies a position where to place the new interceptor. Allowed values are FIRST, LAST, and OTHER_THAN_FIRST_OR_LAST</td>
</tr>
</table>
<div class="element">
<h3 class="heading">property?</h3>
<div class="content">
<p/>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="element">
<h3 class="heading">security?</h3>
<div class="content">
<p>Configures cache-level security.</p>
<div class="element">
<h3 class="heading">authorization?</h3>
<div class="content">
<p>
            Configures authorization for this cache.
          </p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>enabled</td>
<td>boolean</td>
<td>true</td>
<td>
                Enables authorization checks for this cache. Defaults to true if the authorization element is present.
              </td>
</tr>
<tr>
<td>roles</td>
<td/>
<td/>
<td>
                Sets the valid roles required to access this cache.
              </td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
        <div class="element">
<h3 class="heading">distributed-cache-configuration</h3>
<div class="content">
<p>Defines a DIST_* mode cache configuration.</p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>owners</td>
<td>int</td>
<td>2</td>
<td>Number of cluster-wide replicas for each cache entry.</td>
</tr>
<tr>
<td>segments</td>
<td>int</td>
<td>256</td>
<td>Number of hash space segments (per cluster). The default value is 256, and should be at least 20 * cluster size.</td>
</tr>
<tr>
<td>capacity-factor</td>
<td>double</td>
<td>1</td>
<td>Controls the proportion of entries that will reside on the local node,
              compared to the other nodes in the cluster. Value must be positive. The default is 1</td>
</tr>
<tr>
<td>l1-lifespan</td>
<td>long</td>
<td/>
<td>Maximum lifespan in milliseconds of an entry placed in the L1 cache.
               By default L1 is disabled unless a positive value is configured for this attribute.
               If the attribute is not present, L1 is disabled.</td>
</tr>
<tr>
<td>l1-cleanup-interval</td>
<td>long</td>
<td>60000</td>
<td>
              Controls how often a cleanup task to prune L1 tracking data is run. Defaults to 10 minutes.
            </td>
</tr>
<tr>
<td>capacity</td>
<td>float</td>
<td>1</td>
<td>
              Controls the proportion of entries that will reside on the local node, compared to the other nodes
              in the cluster. This is just a suggestion, there is no guarantee that a node with a capacity
              factor of 2 will have twice as many entries as a node with a capacity factor of 1.
            </td>
</tr>
<tr>
<td>consistent-hash-factory</td>
<td>string</td>
<td/>
<td>
              The factory to use for generating the consistent hash.
              Must implement `org.infinispan.distribution.ch.ConsistentHashFactory`.
              E.g. `org.infinispan.distribution.ch.impl.SyncConsistentHashFactory` can be used to guarantee
              that multiple distributed caches use exactly the same consistent hash, which for performance
              reasons is not guaranteed by the default consistent hash factory instance used.
            </td>
</tr>
<tr>
<td>key-partitioner</td>
<td>string</td>
<td/>
<td>
              The name of the key partitioner class.
              Must implement `org.infinispan.distribution.ch.KeyPartitioner`.
              A custom key partitioner can be used as an alternative to grouping, to guarantee that some keys
              are located in the same segment (and thus their primary owner is the same node).
              Since 8.2.
            </td>
</tr>
</table>
<div class="element">
<h3 class="heading">state-transfer?</h3>
<div class="content">
<p>The state transfer configuration for distribution and replicated caches.</p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>enabled</td>
<td>boolean</td>
<td>true</td>
<td>If enabled, this will cause the cache to ask neighboring caches for state when it starts up, so the cache starts 'warm', although it will impact startup time.</td>
</tr>
<tr>
<td>timeout</td>
<td>long</td>
<td>240000</td>
<td>The maximum amount of time (ms) to wait for state from neighboring caches, before throwing an exception and aborting startup.</td>
</tr>
<tr>
<td>chunk-size</td>
<td>integer</td>
<td>512</td>
<td>The number of cache entries to batch in each transfer.</td>
</tr>
<tr>
<td>await-initial-transfer</td>
<td>boolean</td>
<td>true</td>
<td>If enabled, this will cause the cache to wait for initial state transfer to complete before responding to requests.</td>
</tr>
</table>
</div>
</div>
<div class="element">
<h3 class="heading">groups?</h3>
<div class="content">
<p>Configures grouping of data.</p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>enabled</td>
<td>boolean</td>
<td/>
<td>
          Enables or disables grouping.
        </td>
</tr>
</table>
<div class="element">
<h3 class="heading">grouper*</h3>
<div class="content">
<p/>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>class</td>
<td>string</td>
<td/>
<td>
                The class to use to group keys. Must implement org.infinispan.distribution.group.Grouper.
              </td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>mode</td>
<td>
<table class="enumeration">
<tr>
<td title="Enables asynchronous mode.">ASYNC</td>
<td>Enables asynchronous mode.</td>
</tr>
<tr>
<td title="Enables synchronous mode.">SYNC</td>
<td>Enables synchronous mode.</td>
</tr>
</table>
</td>
<td/>
<td>Sets the clustered cache mode, ASYNC for asynchronous operation, or SYNC for synchronous operation.</td>
</tr>
<tr>
<td>queue-size</td>
<td>int</td>
<td>0</td>
<td>Deprecated. In ASYNC mode, this attribute can be used to trigger flushing of the queue when it reaches a specific threshold. A value of 0 (the default) disables the replication queue.</td>
</tr>
<tr>
<td>queue-flush-interval</td>
<td>long</td>
<td>10</td>
<td>Deprecated. In ASYNC mode, this attribute controls how often the asynchronous thread used to flush the replication queue runs. This should be a positive integer which represents thread wakeup time in milliseconds.</td>
</tr>
<tr>
<td>remote-timeout</td>
<td>long</td>
<td>15000</td>
<td>In SYNC mode, the timeout (in ms) used to wait for an acknowledgment when making a remote call, after which the call is aborted and an exception is thrown.</td>
</tr>
</table>
<div class="element">
<h3 class="heading">partition-handling?</h3>
<div class="content">
<p>
                   Configures the way this cache reacts to node crashes and split brains.
                </p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>enabled</td>
<td>boolean</td>
<td/>
<td>
                         Enable/disable the partition handling functionality. Defaults to false.
                      </td>
</tr>
</table>
</div>
</div>
<div>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>name</td>
<td>ID</td>
<td/>
<td>Uniquely identifies this cache within its cache container.</td>
</tr>
<tr>
<td>configuration</td>
<td>IDREF</td>
<td/>
<td>The name of the cache configuration which this configuration inherits from.</td>
</tr>
<tr>
<td>start</td>
<td>
<span class="error">FIXME</span>
</td>
<td/>
<td>Unused XML attribute</td>
</tr>
<tr>
<td>jndi-name</td>
<td>string</td>
<td/>
<td>Unused XML attribute</td>
</tr>
<tr>
<td>module</td>
<td>string</td>
<td/>
<td>Unused XML attribute</td>
</tr>
<tr>
<td>statistics</td>
<td>boolean</td>
<td>true</td>
<td>Determines whether or not the cache should collect statistics.  Keep disabled for optimal performance.</td>
</tr>
<tr>
<td>statistics-available</td>
<td>boolean</td>
<td>true</td>
<td>If set to false, statistics gathering cannot be enabled during runtime. Keep disabled for optimal performance.</td>
</tr>
<tr>
<td>deadlock-detection-spin</td>
<td>long</td>
<td>100</td>
<td>
          Time period that determines how often is lock acquisition attempted within maximum time allowed to acquire a particular lock. Defaults to 100ms.
        </td>
</tr>
<tr>
<td>unreliable-return-values</td>
<td>boolean</td>
<td>false</td>
<td>
          Specifies whether Infinispan is allowed to disregard the Map contract when providing return values for org.infinispan.Cache#put(Object, Object) and org.infinispan.Cache#remove(Object) methods.
        </td>
</tr>
</table>
<div class="element">
<h3 class="heading">backups?</h3>
<div class="content">
<p>The state transfer configuration for distribution and replicated caches.</p>
<div class="element">
<h3 class="heading">backup*</h3>
<div class="content">
<p>Configures a specific site where this cache backups data.</p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>site</td>
<td>string</td>
<td/>
<td>Name of the remote site where this cache backups data.</td>
</tr>
<tr>
<td>strategy</td>
<td>
<table class="enumeration">
<tr>
<td title="Enables asynchronous mode.">ASYNC</td>
<td>Enables asynchronous mode.</td>
</tr>
<tr>
<td title="Enables synchronous mode.">SYNC</td>
<td>Enables synchronous mode.</td>
</tr>
</table>
</td>
<td>ASYNC</td>
<td>The strategy used for backing up data: "SYNC" or "ASYNC". Defaults to "ASYNC"</td>
</tr>
<tr>
<td>failure-policy</td>
<td>
<table class="enumeration">
<tr>
<td title="Ignore backup failures.">IGNORE</td>
<td>Ignore backup failures.</td>
</tr>
<tr>
<td title="Warn of backup failures.">WARN</td>
<td>Warn of backup failures.</td>
</tr>
<tr>
<td title="Fail local operations when a backup failure occurs.">FAIL</td>
<td>Fail local operations when a backup failure occurs.</td>
</tr>
<tr>
<td title="Invoke a user-specified failure policy (set via the failure-policy-class attribute)">CUSTOM</td>
<td>Invoke a user-specified failure policy (set via the failure-policy-class attribute)</td>
</tr>
</table>
</td>
<td>WARN</td>
<td>Decides what the system would do in case of failure during backup. Defaults to "WARN"</td>
</tr>
<tr>
<td>timeout</td>
<td>long</td>
<td>10000</td>
<td>The timeout(millis) to be used when backing up data remotely. Defaults to 10 secs.</td>
</tr>
<tr>
<td>enabled</td>
<td>boolean</td>
<td>true</td>
<td>If 'false' then no data is backed up to this site. Defaults to 'true'.</td>
</tr>
<tr>
<td>two-phase-commit</td>
<td>boolean</td>
<td>false</td>
<td>
          Configures whether the replication happens in a 1PC or 2PC when using SYNC backup strategy. Defaults to "false".
          CacheConfigurationException is thrown when used with ASYNC backup strategy.
        </td>
</tr>
<tr>
<td>failure-policy-class</td>
<td>string</td>
<td/>
<td>
          If the 'backupFailurePolicy' is set to 'CUSTOM' then this attribute is
          required and should
          contain the fully qualified name of a class implementing
          org.infinispan.xsite.CustomFailurePolicy.
        </td>
</tr>
</table>
<div class="element">
<h3 class="heading">take-offline?</h3>
<div class="content">
<p>Determines whether this backup is taken offline (ignored) after a certain number of tries.</p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>after-failures</td>
<td>int</td>
<td>0</td>
<td>The number of failed request operations after which this site should be taken offline. Defaults to 0 (never). A negative value would mean that the site will be taken offline after 'min-wait'.</td>
</tr>
<tr>
<td>min-wait</td>
<td>long</td>
<td>0</td>
<td>The minimal number of millis to wait before taking this site offline, even in the case 'after-failures' is reached. If smaller or equal to 0, then only 'after-failures' is considered.</td>
</tr>
</table>
</div>
</div>
<div class="element">
<h3 class="heading">state-transfer?</h3>
<div class="content">
<p>
            Configures the properties needed to transfer the state for this site.
          </p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>chunk-size</td>
<td>int</td>
<td>512</td>
<td>
                If &gt; 0, the state will be transferred in batches of {@code chunkSize} cache entries.
                If &lt;= 0, the state will be transferred in all at once. Not recommended. Defaults to 512.
              </td>
</tr>
<tr>
<td>timeout</td>
<td>long</td>
<td>1200000</td>
<td>
                The time (in milliseconds) to wait for the backup site acknowledge the state chunk
                received and applied. Default value is 20 min.
              </td>
</tr>
<tr>
<td>max-retries</td>
<td>int</td>
<td>30</td>
<td>
                The maximum number of retries when a push state command fails. A value &lt;= 0 (zero) mean that
                the command will not retry. Default value is 30.
              </td>
</tr>
<tr>
<td>wait-time</td>
<td>long</td>
<td>2000</td>
<td>
                The waiting time (in milliseconds) between each retry. The value should be &gt; 0 (zero). Default
                value is 2 seconds.
              </td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="element">
<h3 class="heading">backup-for?</h3>
<div class="content">
<p>
            Configures this cache as a backup for a remote cache.
          </p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>remote-cache</td>
<td>string</td>
<td/>
<td>
                The name of the remote cache that backups data here.
              </td>
</tr>
<tr>
<td>remote-site</td>
<td>string</td>
<td/>
<td>
                The name of the remote site containing the cache that backups data here.
              </td>
</tr>
</table>
</div>
</div>
<div class="element">
<h3 class="heading">locking?</h3>
<div class="content">
<p>The locking configuration of the cache.</p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>isolation</td>
<td>
<table class="enumeration">
<tr>
<td title="No locking isolation will be performed. This is only valid in local mode. In clustered mode, READ_COMMITTED will be used instead.">NONE</td>
<td>No locking isolation will be performed. This is only valid in local mode. In clustered mode, READ_COMMITTED will be used instead.</td>
</tr>
<tr>
<td title="Unsupported. Actually configures READ_COMMITTED">READ_UNCOMMITTED</td>
<td>Unsupported. Actually configures READ_COMMITTED</td>
</tr>
<tr>
<td title="Read committed is an isolation level that guarantees that any data read is committed at the moment it is read. However, depending on the outcome of other transactions, successive reads may return different results">READ_COMMITTED</td>
<td>Read committed is an isolation level that guarantees that any data read is committed at the moment it is read. However, depending on the outcome of other transactions, successive reads may return different results</td>
</tr>
<tr>
<td title="Repeatable read is an isolation level that guarantees that any data read is committed at the moment it is read and that, within a transaction, successive reads will always return the same data.">REPEATABLE_READ</td>
<td>Repeatable read is an isolation level that guarantees that any data read is committed at the moment it is read and that, within a transaction, successive reads will always return the same data.</td>
</tr>
<tr>
<td title="Unsupported. Actually configures REPEATABLE_READ">SERIALIZABLE</td>
<td>Unsupported. Actually configures REPEATABLE_READ</td>
</tr>
</table>
</td>
<td>READ_COMMITTED</td>
<td>Sets the cache locking isolation level. Infinispan only supports READ_COMMITTED or REPEATABLE_READ isolation level.</td>
</tr>
<tr>
<td>striping</td>
<td>boolean</td>
<td>false</td>
<td>If true, a pool of shared locks is maintained for all entries that need to be locked. Otherwise, a lock is created per entry in the cache. Lock striping helps control memory footprint but may reduce concurrency in the system.</td>
</tr>
<tr>
<td>acquire-timeout</td>
<td>long</td>
<td>10000</td>
<td>Maximum time to attempt a particular lock acquisition.</td>
</tr>
<tr>
<td>concurrency-level</td>
<td>int</td>
<td>32</td>
<td>Concurrency level for lock containers. Adjust this value according to the number of concurrent threads interacting with Infinispan.</td>
</tr>
<tr>
<td>write-skew</td>
<td>boolean</td>
<td>false</td>
<td>
          This setting is only applicable in the case of REPEATABLE_READ. When write skew check is set to false, if the writer at commit time discovers that the working entry and the underlying entry have different versions, the working entry will overwrite the underlying entry. If true, such version conflict - known as a write-skew - will throw an Exception. Defaults to false.
        </td>
</tr>
</table>
</div>
</div>
<div class="element">
<h3 class="heading">transaction?</h3>
<div class="content">
<p>The cache transaction configuration.</p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>mode</td>
<td>
<table class="enumeration">
<tr>
<td title="Cache will not enlist within transactions.">NONE</td>
<td>Cache will not enlist within transactions.</td>
</tr>
<tr>
<td title="Uses batching to group cache operations together.">BATCH</td>
<td>Uses batching to group cache operations together.</td>
</tr>
<tr>
<td title="Cache will enlist within transactions as a javax.transaction.Synchronization">NON_XA</td>
<td>Cache will enlist within transactions as a javax.transaction.Synchronization</td>
</tr>
<tr>
<td title="Cache will enlist within transactions as a javax.transaction.xa.XAResource, without recovery.">NON_DURABLE_XA</td>
<td>Cache will enlist within transactions as a javax.transaction.xa.XAResource, without recovery.</td>
</tr>
<tr>
<td title="Cache will enlist within transactions as a javax.transaction.xa.XAResource, with recovery.">FULL_XA</td>
<td>Cache will enlist within transactions as a javax.transaction.xa.XAResource, with recovery.</td>
</tr>
</table>
</td>
<td>NONE</td>
<td>Sets the cache transaction mode to one of NONE, BATCH, NON_XA, NON_DURABLE_XA, FULL_XA.</td>
</tr>
<tr>
<td>stop-timeout</td>
<td>long</td>
<td>30000</td>
<td>If there are any ongoing transactions when a cache is stopped, Infinispan waits for ongoing remote and local transactions to finish. The amount of time to wait for is defined by the cache stop timeout.</td>
</tr>
<tr>
<td>locking</td>
<td>
<table class="enumeration">
<tr>
<td title="Enables Optimistic locking.">OPTIMISTIC</td>
<td>Enables Optimistic locking.</td>
</tr>
<tr>
<td title="Enables Pessimistic locking.">PESSIMISTIC</td>
<td>Enables Pessimistic locking.</td>
</tr>
</table>
</td>
<td>OPTIMISTIC</td>
<td>The locking mode for this cache, one of OPTIMISTIC or PESSIMISTIC.</td>
</tr>
<tr>
<td>transaction-manager-lookup</td>
<td>string</td>
<td>org.infinispan.transaction.lookup.GenericTransactionManagerLookup.GenericTransactionManagerLookup</td>
<td>
          Configure Transaction manager lookup directly using an instance of TransactionManagerLookup. Calling this method marks the cache as transactional.
        </td>
</tr>
<tr>
<td>complete-timeout</td>
<td>long</td>
<td>60000</td>
<td>
          The duration (millis) in which to keep information about the completion of a transaction. Defaults to 60000.
        </td>
</tr>
<tr>
<td>reaper-interval</td>
<td>long</td>
<td>30000</td>
<td>
          The time interval (millis) at which the thread that cleans up transaction completion information kicks in. Defaults to 30000.
        </td>
</tr>
<tr>
<td>auto-commit</td>
<td>boolean</td>
<td>true</td>
<td>
          If the cache is transactional and transactionAutoCommit is enabled then for single operation transactions the user doesn't need to manually start a transaction, but a transactions is injected by the system. Defaults to true.
        </td>
</tr>
<tr>
<td>protocol</td>
<td>
<table class="enumeration">
<tr>
<td title="">DEFAULT</td>
<td/>
</tr>
<tr>
<td title="">TOTAL_ORDER</td>
<td/>
</tr>
</table>
</td>
<td/>
<td>
          Configures the commit protocol to use.
        </td>
</tr>
<tr>
<td>recovery-cache</td>
<td>string</td>
<td>__recoveryInfoCacheName__</td>
<td>
          Sets the name of the cache where recovery related information is held. The cache's default name is "__recoveryInfoCacheName__"
        </td>
</tr>
<tr>
<td>notifications</td>
<td>boolean</td>
<td>true</td>
<td>
          Enables or disables triggering transactional notifications on cache listeners. By default is enabled.
        </td>
</tr>
</table>
</div>
</div>
<div class="element">
<h3 class="heading">eviction?</h3>
<div class="content">
<p>The cache eviction configuration.</p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>strategy</td>
<td>
<table class="enumeration">
<tr>
<td title="Never evict entries. This is the default.">NONE</td>
<td>Never evict entries. This is the default.</td>
</tr>
<tr>
<td title="Actually activates LRU.">UNORDERED</td>
<td>Actually activates LRU.</td>
</tr>
<tr>
<td title="Deprecated. Actually activates LRU.">FIFO</td>
<td>Deprecated. Actually activates LRU.</td>
</tr>
<tr>
<td title="Least-Recently Used policy.">LRU</td>
<td>Least-Recently Used policy.</td>
</tr>
<tr>
<td title="Low Inter-reference Recency Set. An improved version of LRU which uses cache-locality access information to better decide which data to evict.">LIRS</td>
<td>Low Inter-reference Recency Set. An improved version of LRU which uses cache-locality access information to better decide which data to evict.</td>
</tr>
<tr>
<td title="Eviction will be performed manually. Equivalent internally to NONE.">MANUAL</td>
<td>Eviction will be performed manually. Equivalent internally to NONE.</td>
</tr>
</table>
</td>
<td>NONE</td>
<td>Sets the cache eviction strategy. Available options are 'UNORDERED', 'FIFO', 'LRU', 'LIRS' and 'NONE' (to disable eviction).</td>
</tr>
<tr>
<td>max-entries</td>
<td>long</td>
<td>-1</td>
<td>Deprecated since 8.1. Use the size attribute instead.</td>
</tr>
<tr>
<td>thread-policy</td>
<td>
<table class="enumeration">
<tr>
<td title="Fires the eviction events from the same thread which is performing the eviction ">PIGGYBACK</td>
<td>Fires the eviction events from the same thread which is performing the eviction </td>
</tr>
<tr>
<td title="Use the default eviction listener thread policy (PIGGYBACK)">DEFAULT</td>
<td>Use the default eviction listener thread policy (PIGGYBACK)</td>
</tr>
</table>
</td>
<td>DEFAULT</td>
<td>
          Threading policy for eviction. Defaults to using the DEFAULT eviction policy.
        </td>
</tr>
<tr>
<td>type</td>
<td>
<table class="enumeration">
<tr>
<td title="Evicts entries from the cache when a specified count has been set">COUNT</td>
<td>Evicts entries from the cache when a specified count has been set</td>
</tr>
<tr>
<td title="Evicts entries from the cache when a specified memory usage has been reached. Memory usage is computed using an approximation which is tailored for the HotSpot VM. This can only be used when both key and values are stored as byte arrays. To guarantee only byte arrays are stored it is recommended to run with store as binary for both keys and values">MEMORY</td>
<td>Evicts entries from the cache when a specified memory usage has been reached. Memory usage is computed using an approximation which is tailored for the HotSpot VM. This can only be used when both key and values are stored as byte arrays. To guarantee only byte arrays are stored it is recommended to run with store as binary for both keys and values</td>
</tr>
</table>
</td>
<td>COUNT</td>
<td>Specifies whether to use entry count or memory-based approximation to decide when to evict entries.</td>
</tr>
<tr>
<td>size</td>
<td>long</td>
<td>-1</td>
<td>Maximum size to use for eviction. When using the COUNT type, this is the maximum number of entries in a cache instance. When using the MEMORY threshold policy, this is the maximum number of allocated bytes used by a cache's datacontainer. A value of -1 means no limit. This is currently limited to 2^48 - 1 in size.</td>
</tr>
</table>
</div>
</div>
<div class="element">
<h3 class="heading">expiration?</h3>
<div class="content">
<p>The cache expiration configuration.</p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>max-idle</td>
<td>long</td>
<td>-1</td>
<td>Maximum idle time a cache entry will be maintained in the cache, in milliseconds. If the idle time is exceeded, the entry will be expired cluster-wide. -1 means the entries never expire.</td>
</tr>
<tr>
<td>lifespan</td>
<td>long</td>
<td>-1</td>
<td>Maximum lifespan of a cache entry, after which the entry is expired cluster-wide, in milliseconds. -1 means the entries never expire.</td>
</tr>
<tr>
<td>interval</td>
<td>long</td>
<td>60000</td>
<td>Interval (in milliseconds) between subsequent runs to purge expired entries from memory and any cache stores. If you wish to disable the periodic eviction process altogether, set interval to -1.</td>
</tr>
</table>
</div>
</div>
<div class="element">
<h3 class="heading">compatibility?</h3>
<div class="content">
<p>The cache compatibility mode configuration.</p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>marshaller</td>
<td>string</td>
<td/>
<td>A marshaller to use for compatibility conversions.</td>
</tr>
</table>
</div>
</div>
<div class="element">
<h3 class="heading">store-as-binary?</h3>
<div class="content">
<p>Configures the cache to store data in binary format.</p>
        Controls whether when stored in memory, keys and values are stored as references to their original objects, or in a serialized, binary format.  There are benefits to both approaches, but often if used in a clustered mode, storing objects as binary means that the cost of serialization happens early on, and can be amortized.  Further, deserialization costs are incurred lazily which improves throughput. It is possible to control this on a fine-grained basis: you can choose to just store keys or values as binary, or both.
      <table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>keys</td>
<td>boolean</td>
<td>true</td>
<td>
          Specify whether keys are stored as binary or not. Enabled by default if the "enabled" attribute is set to true.
        </td>
</tr>
<tr>
<td>values</td>
<td>boolean</td>
<td>true</td>
<td>
          Specify whether values are stored as binary or not. Enabled by default if the "enabled" attribute is set to true.
        </td>
</tr>
</table>
</div>
</div>
<div class="element">
<h3 class="heading">persistence?</h3>
<div class="content">
<p>Configures the cache's persistence layer.</p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>passivation</td>
<td>boolean</td>
<td>false</td>
<td>
          If true, data is only written to the cache store when it is evicted from memory, a phenomenon known as 'passivation'. Next time the data is requested, it will be 'activated' which means that data will be brought back to memory and removed from the persistent store. This gives you the ability to 'overflow' to disk, similar to swapping in an operating system. If false, the cache store contains a copy of the contents in memory, so writes to cache result in cache store writes. This essentially gives you a 'write-through' configuration. Defaults to false.
        </td>
</tr>
</table>
</div>
</div>
<div class="element">
<h3 class="heading">versioning?</h3>
<div class="content">
<p>
            Controls whether entries are versioned.  Versioning is necessary, for example, when using optimistic transactions in a clustered environment, to be able to perform write-skew checks.
          </p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>scheme</td>
<td>
<table class="enumeration">
<tr>
<td title="&#10;            A simple versioning scheme that is cluster-aware&#10;          ">SIMPLE</td>
<td>
            A simple versioning scheme that is cluster-aware
          </td>
</tr>
<tr>
<td title="&#10;            Don't version entries&#10;          ">NONE</td>
<td>
            Don't version entries
          </td>
</tr>
</table>
</td>
<td>NONE</td>
<td>
          The scheme to use when versioning entries. Can be either SIMPLE or NONE. Defaults to NONE
        </td>
</tr>
</table>
</div>
</div>
<div class="element">
<h3 class="heading">data-container?</h3>
<div class="content">
<p>
            Controls the data container for the cache.
          </p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>class</td>
<td>string</td>
<td/>
<td>
          DEPRECATED: this is to be removed in a future release
          Fully qualified class name of the data container to use
        </td>
</tr>
<tr>
<td>key-equivalence</td>
<td>string</td>
<td/>
<td>
          Fully qualified class name of the Equivalence class to use
          for keys stored in the cache, which provides with custom
          ways to compare cached keys
        </td>
</tr>
<tr>
<td>value-equivalence</td>
<td>string</td>
<td/>
<td>
          Fully qualified class name of the Equivalence class to use
          for values stored in the cache, which provides with custom
          ways to compare cached values
        </td>
</tr>
</table>
<div class="element">
<h3 class="heading">property*</h3>
<div class="content">
<p>Properties passed to the data container</p>
</div>
</div>
</div>
</div>
<div class="element">
<h3 class="heading">modules?</h3>
<div class="content">
<p>
            This element contains configuration options for additional modules which affect cache configuration
          </p>
</div>
</div>
<div class="element">
<h3 class="heading">indexing?</h3>
<div class="content">
<p>
            Defines indexing options for cache
          </p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>index</td>
<td>
<table class="enumeration">
<tr>
<td title="Do not index data. This is the default.">NONE</td>
<td>Do not index data. This is the default.</td>
</tr>
<tr>
<td title="Only index changes made locally, ignoring remote changes. This is useful if indexes are shared across a cluster to prevent redundant indexing of updates.">LOCAL</td>
<td>Only index changes made locally, ignoring remote changes. This is useful if indexes are shared across a cluster to prevent redundant indexing of updates.</td>
</tr>
<tr>
<td title="Index all data">ALL</td>
<td>Index all data</td>
</tr>
</table>
</td>
<td>NONE</td>
<td>The indexing mode of the cache. Defaults to NONE.</td>
</tr>
<tr>
<td>auto-config</td>
<td>boolean</td>
<td>false</td>
<td>Whether or not to apply automatic index configuration based on cache type</td>
</tr>
</table>
<div class="element">
<h3 class="heading">indexed-entities?</h3>
<div class="content">
<p>Defines the indexed entity classes</p>
<div class="element">
<h3 class="heading">indexed-entity*</h3>
<div class="content">
<p>Indexed entity class name</p>
</div>
</div>
</div>
</div>
<div class="element">
<h3 class="heading">property*</h3>
<div class="content">
<p>Property to pass on to the indexing system</p>
</div>
</div>
</div>
</div>
<div class="element">
<h3 class="heading">custom-interceptors?</h3>
<div class="content">
<p>Configures custom interceptors to be added to the cache.</p>
<div class="element">
<h3 class="heading">interceptor*</h3>
<div class="content">
<p/>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>after</td>
<td>string</td>
<td/>
<td>Dictates that the custom interceptor appears immediately after the specified interceptor. If the specified interceptor is not found in the interceptor chain, a ConfigurationException will be thrown when the cache starts.</td>
</tr>
<tr>
<td>before</td>
<td>string</td>
<td/>
<td>Dictates that the custom interceptor appears immediately before the specified interceptor. If the specified interceptor is not found in the interceptor chain, a ConfigurationException will be thrown when the cache starts.</td>
</tr>
<tr>
<td>class</td>
<td>string</td>
<td/>
<td>A fully qualified class name of the new custom interceptor to add to the configuration.</td>
</tr>
<tr>
<td>index</td>
<td>int</td>
<td/>
<td>Specifies a position in the interceptor chain to place the new interceptor. The index starts at 0 and goes up to the number of interceptors in a given configuration. A ConfigurationException is thrown if the index is less than 0 or greater than the maximum number of interceptors in the chain.</td>
</tr>
<tr>
<td>position</td>
<td>string</td>
<td/>
<td>Specifies a position where to place the new interceptor. Allowed values are FIRST, LAST, and OTHER_THAN_FIRST_OR_LAST</td>
</tr>
</table>
<div class="element">
<h3 class="heading">property?</h3>
<div class="content">
<p/>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="element">
<h3 class="heading">security?</h3>
<div class="content">
<p>Configures cache-level security.</p>
<div class="element">
<h3 class="heading">authorization?</h3>
<div class="content">
<p>
            Configures authorization for this cache.
          </p>
<table>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
<tr>
<td>enabled</td>
<td>boolean</td>
<td>true</td>
<td>
                Enables authorization checks for this cache. Defaults to true if the authorization element is present.
              </td>
</tr>
<tr>
<td>roles</td>
<td/>
<td/>
<td>
                Sets the valid roles required to access this cache.
              </td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
      </div>
</div>
</div>
</div>
<div id="global">
<a href="#">Expand/Collapse All</a>
</div>
</body>
</html>
